

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Building Your First Network - 构建你的第一个网络 &mdash; hyperledger-fabricdocs master documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Writing Your First Application - 编写你的第一个应用" href="write_first_app.html" />
    <link rel="prev" title="Tutorials - 教程" href="tutorials.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          


          
            <a href="index.html" class="icon icon-home"> hyperledger-fabricdocs
          

          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
<br>
<a href="https://chat.hyperledger.org">Rocket Chat</a>  <a href="https://jenkins.hyperledger.org/">CI</a>
<a href="http://stackoverflow.com/questions/tagged/hyperledger-fabric">StackOverflow</a>
<br>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
  <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
  <br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">欢迎来到 Hyperledger Fabric</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="getting_started.html">入门指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="key_concepts.html">Key Concepts</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="tutorials.html">Tutorials - 教程</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Building Your First Network - 构建你的第一个网络</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#install-prerequisites">Install prerequisites - 安装依赖</a></li>
<li class="toctree-l4"><a class="reference internal" href="#want-to-run-it-now">Want to run it now? - 是否已经迫不及待想要开始了？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crypto-generator">Crypto Generator - 加密文件的生成</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-transaction-generator">Configuration Transaction Generator - 配置交易的生成</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run-the-tools">Run the tools - 运行工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="#start-the-network">Start the network - 启动网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#understanding-the-docker-compose-topology-docker-compose">Understanding the Docker Compose topology - 理解 Docker Compose 的拓扑结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-couchdb-couchdb">Using CouchDB - 使用 CouchDB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-couchdb-couchdb">Why CouchDB - 为何使用 CouchDB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-note-on-data-persistence">A Note on Data Persistence - 数据持久化的注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#troubleshooting">Troubleshooting - 疑难解答</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="write_first_app.html">Writing Your First Application - 编写你的第一个应用</a></li>
<li class="toctree-l3"><a class="reference internal" href="channel_update_tutorial.html">Adding an Org to a Channel</a></li>
<li class="toctree-l3"><a class="reference internal" href="upgrading_your_network_tutorial.html">Upgrading Your Network Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="chaincode.html">Chaincode Tutorials 链码指南</a></li>
<li class="toctree-l3"><a class="reference internal" href="chaincode4ade.html">Chaincode for Developers</a></li>
<li class="toctree-l3"><a class="reference internal" href="chaincode4noah.html">Chaincode for Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="systemchaincode.html">System Chaincode Plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="videos.html">Videos</a></li>
<li class="toctree-l3"><a class="reference internal" href="videos.html#id1">视频</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ops_guide.html">Operations Guides</a></li>
<li class="toctree-l2"><a class="reference internal" href="command_ref.html">Commands Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="architecture.html">架构参考</a></li>
<li class="toctree-l2"><a class="reference internal" href="Fabric-FAQ.html">Hyperledger Fabric FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="ordering-service-faq.html">Ordering Service FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="CONTRIBUTING.html">Contributions Welcome!</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">Glossary - 词汇表</a></li>
<li class="toctree-l2"><a class="reference internal" href="releases.html">Release Notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="questions.html">Still Have Questions? - 依然遇到问题？</a></li>
<li class="toctree-l2"><a class="reference internal" href="status.html">Status - 状态</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">入门指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="key_concepts.html">Key Concepts</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tutorials.html">Tutorials - 教程</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Building Your First Network - 构建你的第一个网络</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#install-prerequisites">Install prerequisites - 安装依赖</a></li>
<li class="toctree-l3"><a class="reference internal" href="#want-to-run-it-now">Want to run it now? - 是否已经迫不及待想要开始了？</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#generate-network-artifacts">Generate Network Artifacts - 生成网络配置工件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bring-up-the-network">Bring Up the Network - 启动整个网络</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bring-down-the-network">Bring Down the Network - 关闭整个网络</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#crypto-generator">Crypto Generator - 加密文件的生成</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#how-does-it-work">How does it work? - 它是如何工作的？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#configuration-transaction-generator">Configuration Transaction Generator - 配置交易的生成</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">How does it work? - 它是如何工作的？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#run-the-tools">Run the tools - 运行工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#manually-generate-the-artifacts">Manually generate the artifacts - 手动生成</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-a-channel-configuration-transaction">Create a Channel Configuration Transaction - 创建通道配置交易</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#start-the-network">Start the network - 启动网络</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#environment-variables">Environment variables - 环境变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-join-channel">Create &amp; Join Channel - 创建和加入通道</a></li>
<li class="toctree-l4"><a class="reference internal" href="#update-the-anchor-peers">Update the anchor peers - 更新锚节点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#install-instantiate-chaincode">Install &amp; Instantiate Chaincode - 安装和实例化链码</a></li>
<li class="toctree-l4"><a class="reference internal" href="#query">Query - 查询</a></li>
<li class="toctree-l4"><a class="reference internal" href="#invoke">Invoke - 调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">Query - 查询</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-s-happening-behind-the-scenes">What’s happening behind the scenes? - 背后发生了什么？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-does-this-demonstrate">What does this demonstrate? - 演示了哪些内容？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-do-i-see-these-transactions">How do I see these transactions? - 如何查看交易的具体信息？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-can-i-see-the-chaincode-logs">How can I see the chaincode logs? - 如何查看链码的日志？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#understanding-the-docker-compose-topology-docker-compose">Understanding the Docker Compose topology - 理解 Docker Compose 的拓扑结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-couchdb-couchdb">Using CouchDB - 使用 CouchDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-couchdb-couchdb">Why CouchDB - 为何使用 CouchDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="#a-note-on-data-persistence">A Note on Data Persistence - 数据持久化的注意事项</a></li>
<li class="toctree-l3"><a class="reference internal" href="#troubleshooting">Troubleshooting - 疑难解答</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="write_first_app.html">Writing Your First Application - 编写你的第一个应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="channel_update_tutorial.html">Adding an Org to a Channel</a></li>
<li class="toctree-l2"><a class="reference internal" href="upgrading_your_network_tutorial.html">Upgrading Your Network Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="chaincode.html">Chaincode Tutorials 链码指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="chaincode4ade.html">Chaincode for Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="chaincode4noah.html">Chaincode for Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="systemchaincode.html">System Chaincode Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="videos.html">Videos</a></li>
<li class="toctree-l2"><a class="reference internal" href="videos.html#id1">视频</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ops_guide.html">Operations Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_ref.html">Commands Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">架构参考</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fabric-FAQ.html">Hyperledger Fabric FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="ordering-service-faq.html">Ordering Service FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributions Welcome!</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary - 词汇表</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="questions.html">Still Have Questions? - 依然遇到问题？</a></li>
<li class="toctree-l1"><a class="reference internal" href="status.html">Status - 状态</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">hyperledger-fabricdocs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="tutorials.html">Tutorials - 教程</a> &raquo;</li>
        
      <li>Building Your First Network - 构建你的第一个网络</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/build_network.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p><em>Needs Review</em></p>
<div class="section" id="building-your-first-network">
<h1>Building Your First Network - 构建你的第一个网络<a class="headerlink" href="#building-your-first-network" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>These instructions have been verified to work against the
latest stable Docker images and the pre-compiled
setup utilities within the supplied tar file. If you run
these commands with images or tools from the current master
branch, it is possible that you will see configuration and panic
errors.</p>
<p class="last">本篇指南是针对稳定版（v1.1.0） Docker 镜像和预编译好的工具进行设计和校验。
如果你基于当前代码的 master 分支运行本篇指南提到的命令，有可能会遇到配置错误或者宕机等问题。</p>
</div>
<p>The build your first network (BYFN) scenario provisions a sample Hyperledger
Fabric network consisting of two organizations, each maintaining two peer
nodes, and a “solo” ordering service.</p>
<p>本方案 (“构建你的第一个网络”，BYFN) 提供了一个 Hyperledger Fabric 的示例网络，该网络包含两个机构 (Organization)，每个机构各自拥有两个对等节点 (peer)，并提供 “独自(solo)” 模式的排序服务 (Ordering Service)。</p>
<div class="section" id="install-prerequisites">
<h2>Install prerequisites - 安装依赖<a class="headerlink" href="#install-prerequisites" title="Permalink to this headline">¶</a></h2>
<p>Before we begin, if you haven’t already done so, you may wish to check that
you have all the <a class="reference internal" href="prereqs.html"><span class="doc">预备知识</span></a> installed on the platform(s)
on which you’ll be developing blockchain applications and/or operating
Hyperledger Fabric.</p>
<p>在开始前，请确认你已经按照 <a class="reference internal" href="prereqs.html"><span class="doc">预备知识</span></a> 的介绍，在你准备开发和运行 Hyperledger Fabric 的电脑上安装了所有的依赖软件。</p>
<p>You will also need to download and install the <a class="reference internal" href="samples.html"><span class="doc">Hyperledger Fabric 示例</span></a>. You will notice
that there are a number of samples included in the <code class="docutils literal notranslate"><span class="pre">fabric-samples</span></code>
repository. We will be using the <code class="docutils literal notranslate"><span class="pre">first-network</span></code> sample. Let’s open that
sub-directory now.</p>
<p>你还需要下载和安装 <a class="reference internal" href="samples.html"><span class="doc">Hyperledger Fabric 示例</span></a>。你会注意到在 <code class="docutils literal notranslate"><span class="pre">fabric-samples</span></code> 项目中包含了一系列的示例。我们会使用 <code class="docutils literal notranslate"><span class="pre">first-network</span></code> 示例，下面请进入该示例的子目录：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">fabric</span><span class="o">-</span><span class="n">samples</span><span class="o">/</span><span class="n">first</span><span class="o">-</span><span class="n">network</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The supplied commands in this documentation
<strong>MUST</strong> be run from your <code class="docutils literal notranslate"><span class="pre">first-network</span></code> sub-directory
of the <code class="docutils literal notranslate"><span class="pre">fabric-samples</span></code> repository clone.  If you elect to run the
commands from a different location, the various provided scripts
will be unable to find the binaries.</p>
<p class="last">本文档中提供的命令 <strong>必须</strong> 在 <code class="docutils literal notranslate"><span class="pre">fabric-samples</span></code> 项目的 <code class="docutils literal notranslate"><span class="pre">first-network</span></code> 子目录下执行。如果你从其他位置执行命令，示例中提供的各种脚本将无法找到所需的可执行文件。</p>
</div>
</div>
<div class="section" id="want-to-run-it-now">
<h2>Want to run it now? - 是否已经迫不及待想要开始了？<a class="headerlink" href="#want-to-run-it-now" title="Permalink to this headline">¶</a></h2>
<p>We provide a fully annotated script - <code class="docutils literal notranslate"><span class="pre">byfn.sh</span></code> - that leverages these Docker
images to quickly bootstrap a Hyperledger Fabric network comprised of 4 peers
representing two different organizations, and an orderer node. It will also
launch a container to run a scripted execution that will join peers to a
channel, deploy and instantiate chaincode and drive execution of transactions
against the deployed chaincode.</p>
<p>我们提供了一个包含完整注释的脚本 <code class="docutils literal notranslate"><span class="pre">byfn.sh</span></code> ，利用 Docker 镜像快速构建起一个 Hyperledger Fabric 网络，该网络包含 2 个机构下的共 4 个对等节点 (peer)，以及 1 个排序服务节点 (orderer)。同时，我们还会启动一个容器来运行脚本，实现如下功能：将对等节点添加到通道 (channel)、部署和初始化链码 (chaincode) 以及执行已部署链码的交易。</p>
<p>Here’s the help text for the <code class="docutils literal notranslate"><span class="pre">byfn.sh</span></code> script:</p>
<p>如下是 <code class="docutils literal notranslate"><span class="pre">byfn.sh</span></code> 脚本的帮助说明</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>./byfn.sh --help
Usage:
byfn.sh up|down|restart|generate [-c &lt;channel name&gt;] [-t &lt;timeout&gt;] [-d &lt;delay&gt;] [-f &lt;docker-compose-file&gt;] [-s &lt;dbtype&gt;]
byfn.sh -h|--help (print this message 打印本消息)
  -m &lt;mode&gt; - one of &#39;up&#39;, &#39;down&#39;, &#39;restart&#39; or &#39;generate&#39;
    - &#39;up&#39; - bring up the network with docker-compose up 使用 docker-compose up 命令启动本网络
    - &#39;down&#39; - clear the network with docker-compose down 使用 docker-compose down 命令关闭本网络
    - &#39;restart&#39; - restart the network 重启本网络
    - &#39;generate&#39; - generate required certificates and genesis block 生成需要的证书文件和初始区块
  -c &lt;channel name&gt; - channel name to use (defaults to &quot;mychannel&quot;) channel 名称 (默认是 &quot;mychannel&quot;)
  -t &lt;timeout&gt; - CLI timeout duration in seconds (defaults to 10) 客户端超时时间 (默认是 10 秒)
  -d &lt;delay&gt; - delay duration in seconds (defaults to 3) 延时时间 (默认是 3 秒)
  -f &lt;docker-compose-file&gt; - specify which docker-compose file use (defaults to docker-compose-cli.yaml) 指定使用的 docker-compose 文件 (默认是 docker-compose-cli.yaml)
  -s &lt;dbtype&gt; - the database backend to use: goleveldb (default) or couchdb 所使用的数据库: goleveldb (默认) 或者 couchdb
  -l &lt;language&gt; - the chaincode language: golang (default) or node chaincode 编程语言: golang (默认) 或者 node
  -a - don&#39;t ask for confirmation before proceeding 在运行前无需确认

  Typically, one would first generate the required certificates and
  genesis block, then bring up the network. e.g.:

  一般情况下，可以先生成需要的证书文件和初始区块，随后启动整个网络。例如:

      byfn.sh -m generate -c mychannel
      byfn.sh -m up -c mychannel -s couchdb
</pre></div>
</div>
<p>If you choose not to supply a channel name, then the
script will use a default name of <code class="docutils literal notranslate"><span class="pre">mychannel</span></code>.  The CLI timeout parameter
(specified with the -t flag) is an optional value; if you choose not to set
it, then the CLI will give up on query requests made after the default
setting of 10 seconds.</p>
<p>如果你没有指定通道名称，该脚本会使用默认的通道名称 <code class="docutils literal notranslate"><span class="pre">mychannel</span></code>。客户端超时时间 (由 -t 选项指定)是一个可选项，如果你没有设置它，客户端会在默认的 10 秒超时时间后，放弃查询请求。</p>
<div class="section" id="generate-network-artifacts">
<h3>Generate Network Artifacts - 生成网络配置工件<a class="headerlink" href="#generate-network-artifacts" title="Permalink to this headline">¶</a></h3>
<p>Ready to give it a go? Okay then! Execute the following command:</p>
<p>是否已经准备好开始了？好的，开始执行如下命令</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">byfn</span><span class="o">.</span><span class="n">sh</span> <span class="o">-</span><span class="n">m</span> <span class="n">generate</span>
</pre></div>
</div>
<p>You will see a brief description as to what will occur, along with a yes/no command line
prompt. Respond with a <code class="docutils literal notranslate"><span class="pre">y</span></code> or hit the return key to execute the described action.</p>
<p>你会看到一个简短的描述，以及一个 yes/no 的提示。输入 <code class="docutils literal notranslate"><span class="pre">y</span></code> 及回车键，将会执行所描述的相应动作。</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>Generating certs and genesis block for with channel &#39;mychannel&#39; and CLI timeout of &#39;10&#39;
Continue? [Y/n] y
proceeding ...
/Users/xxx/dev/fabric-samples/bin/cryptogen

##########################################################
##### Generate certificates using cryptogen tool #########
##########################################################
org1.example.com
2017-06-12 21:01:37.334 EDT [bccsp] GetDefault -&gt; WARN 001 Before using BCCSP, please call InitFactories(). Falling back to bootBCCSP.
...

/Users/xxx/dev/fabric-samples/bin/configtxgen
##########################################################
#########  Generating Orderer Genesis block ##############
##########################################################
2017-06-12 21:01:37.558 EDT [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2017-06-12 21:01:37.562 EDT [msp] getMspConfig -&gt; INFO 002 intermediate certs folder not found at [/Users/xxx/dev/byfn/crypto-config/ordererOrganizations/example.com/msp/intermediatecerts]. Skipping.: [stat /Users/xxx/dev/byfn/crypto-config/ordererOrganizations/example.com/msp/intermediatecerts: no such file or directory]
...
2017-06-12 21:01:37.588 EDT [common/configtx/tool] doOutputBlock -&gt; INFO 00b Generating genesis block
2017-06-12 21:01:37.590 EDT [common/configtx/tool] doOutputBlock -&gt; INFO 00c Writing genesis block

#################################################################
### Generating channel configuration transaction &#39;channel.tx&#39; ###
#################################################################
2017-06-12 21:01:37.634 EDT [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2017-06-12 21:01:37.644 EDT [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 002 Generating new channel configtx
2017-06-12 21:01:37.645 EDT [common/configtx/tool] doOutputChannelCreateTx -&gt; INFO 003 Writing new channel tx

#################################################################
#######    Generating anchor peer update for Org1MSP   ##########
#################################################################
2017-06-12 21:01:37.674 EDT [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2017-06-12 21:01:37.678 EDT [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update
2017-06-12 21:01:37.679 EDT [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update

#################################################################
#######    Generating anchor peer update for Org2MSP   ##########
#################################################################
2017-06-12 21:01:37.700 EDT [common/configtx/tool] main -&gt; INFO 001 Loading configuration
2017-06-12 21:01:37.704 EDT [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 002 Generating anchor peer update
2017-06-12 21:01:37.704 EDT [common/configtx/tool] doOutputAnchorPeersUpdate -&gt; INFO 003 Writing anchor peer update
</pre></div>
</div>
<p>This first step generates all of the certificates and keys for our various
network entities, the <code class="docutils literal notranslate"><span class="pre">genesis</span> <span class="pre">block</span></code> used to bootstrap the ordering service,
and a collection of configuration transactions required to configure a
<a class="reference internal" href="glossary.html#channel"><span class="std std-ref">Channel - 通道</span></a>.</p>
<p>在第一步中，生成了如下文件：我们多个网络实体的证书和密钥、用于启动排序服务的 <code class="docutils literal notranslate"><span class="pre">初始区块(genesis</span> <span class="pre">block)</span></code> 以及配置 <a class="reference internal" href="glossary.html#channel"><span class="std std-ref">Channel - 通道</span></a> 所需的一系列配置交易。</p>
</div>
<div class="section" id="bring-up-the-network">
<h3>Bring Up the Network - 启动整个网络<a class="headerlink" href="#bring-up-the-network" title="Permalink to this headline">¶</a></h3>
<p>Next, you can bring the network up with one of the following commands:</p>
<p>接下来，你可以使用如下命令，启动整个网络</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">byfn</span><span class="o">.</span><span class="n">sh</span> <span class="o">-</span><span class="n">m</span> <span class="n">up</span>
</pre></div>
</div>
<p>The above command will compile Golang chaincode images and spin up the corresponding
containers.  Go is the default chaincode language, however there is also support
for <a class="reference external" href="https://fabric-shim.github.io/">Node.js</a> chaincode.  If you’d like to run through this tutorial with node
chaincode, pass the following command instead:</p>
<p>上述命令会编译 Golang 链码镜像并启动相应的容器。Go 语言是默认的链码编程语言，同时还支持使用 <a class="reference external" href="https://fabric-shim.github.io/">Node.js</a> 编写链码。如果你希望基于 node 链码运行本教程，使用如下的命令：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># we use the -l flag to specify the chaincode language</span>
<span class="c1"># forgoing the -l flag will default to Golang</span>

<span class="o">./</span><span class="n">byfn</span><span class="o">.</span><span class="n">sh</span> <span class="o">-</span><span class="n">m</span> <span class="n">up</span> <span class="o">-</span><span class="n">l</span> <span class="n">node</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>View the <a class="reference external" href="https://fabric-shim.github.io/ChaincodeStub.html">Hyperledger Fabric Shim</a>
documentation for more info on the node.js chaincode shim APIs.</p>
<p class="last">阅读 <a class="reference external" href="https://fabric-shim.github.io/ChaincodeStub.html">Hyperledger Fabric Shim</a> 文档，获取更多关于 node.js 链码 API 的信息。</p>
</div>
<p>Once again, you will be prompted as to whether you wish to continue or abort.
Respond with a <code class="docutils literal notranslate"><span class="pre">y</span></code> or hit the return key:</p>
<p>和之前类似，会提示你是否继续或者终止。输入 <code class="docutils literal notranslate"><span class="pre">y</span></code> 以及回车键继续：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>Starting with channel &#39;mychannel&#39; and CLI timeout of &#39;10&#39;
Continue? [Y/n]
proceeding ...
Creating network &quot;net_byfn&quot; with the default driver
Creating peer0.org1.example.com
Creating peer1.org1.example.com
Creating peer0.org2.example.com
Creating orderer.example.com
Creating peer1.org2.example.com
Creating cli


 ____    _____      _      ____    _____
/ ___|  |_   _|    / \    |  _ \  |_   _|
\___ \    | |     / _ \   | |_) |   | |
 ___) |   | |    / ___ \  |  _ &lt;    | |
|____/    |_|   /_/   \_\ |_| \_\   |_|

Channel name : mychannel
Creating channel...
</pre></div>
</div>
<p>The logs will continue from there. This will launch all of the containers, and
then drive a complete end-to-end application scenario. Upon successful
completion, it should report the following in your terminal window:</p>
<p>日志将从这里开始。随后会启动所有的容器，然后完成一个完整的端到端的应用场景。执行成功后，在终端窗口中会看到以下的内容：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Query</span> <span class="n">Result</span><span class="p">:</span> <span class="mi">90</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">16</span> <span class="mi">17</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">15.158</span> <span class="n">UTC</span> <span class="p">[</span><span class="n">main</span><span class="p">]</span> <span class="n">main</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">008</span> <span class="n">Exiting</span><span class="o">.....</span>
<span class="o">=====================</span> <span class="n">Query</span> <span class="n">on</span> <span class="n">peer1</span><span class="o">.</span><span class="n">org2</span> <span class="n">on</span> <span class="n">channel</span> <span class="s1">&#39;mychannel&#39;</span> <span class="ow">is</span> <span class="n">successful</span> <span class="o">=====================</span>

<span class="o">=====================</span> <span class="n">All</span> <span class="n">GOOD</span><span class="p">,</span> <span class="n">BYFN</span> <span class="n">execution</span> <span class="n">completed</span> <span class="o">=====================</span>


 <span class="n">_____</span>   <span class="n">_</span>   <span class="n">_</span>   <span class="n">____</span>
<span class="o">|</span> <span class="n">____</span><span class="o">|</span> <span class="o">|</span> \ <span class="o">|</span> <span class="o">|</span> <span class="o">|</span>  <span class="n">_</span> \
<span class="o">|</span>  <span class="n">_</span><span class="o">|</span>   <span class="o">|</span>  \<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span><span class="n">___</span>  <span class="o">|</span> <span class="o">|</span>\  <span class="o">|</span> <span class="o">|</span> <span class="o">|</span><span class="n">_</span><span class="o">|</span> <span class="o">|</span>
<span class="o">|</span><span class="n">_____</span><span class="o">|</span> <span class="o">|</span><span class="n">_</span><span class="o">|</span> \<span class="n">_</span><span class="o">|</span> <span class="o">|</span><span class="n">____</span><span class="o">/</span>
</pre></div>
</div>
<p>You can scroll through these logs to see the various transactions. If you don’t
get this result, then jump down to the <a class="reference internal" href="#troubleshoot"><span class="std std-ref">Troubleshooting - 疑难解答</span></a> section and let’s see
whether we can help you discover what went wrong.</p>
<p>你可以滚动浏览这些日志，查看其中的各种交易。如果你没有看到上述内容，请查看 <a class="reference internal" href="#troubleshoot"><span class="std std-ref">Troubleshooting - 疑难解答</span></a> 章节，看看我们能否帮助你发现问题所在。</p>
</div>
<div class="section" id="bring-down-the-network">
<h3>Bring Down the Network - 关闭整个网络<a class="headerlink" href="#bring-down-the-network" title="Permalink to this headline">¶</a></h3>
<p>Finally, let’s bring it all down so we can explore the network setup one step
at a time. The following will kill your containers, remove the crypto material
and four artifacts, and delete the chaincode images from your Docker Registry:</p>
<p>最后，让我们关闭整个网络，以便我们可以逐步来学习网络的配置。接下来，将关闭你的容器，删除加密文件和四个配置工件，并从你的 Docker 镜像库中删除链码镜像：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">byfn</span><span class="o">.</span><span class="n">sh</span> <span class="o">-</span><span class="n">m</span> <span class="n">down</span>
</pre></div>
</div>
<p>Once again, you will be prompted to continue, respond with a <code class="docutils literal notranslate"><span class="pre">y</span></code> or hit the return key:</p>
<p>再一次的，会提示你是否继续，输入 <code class="docutils literal notranslate"><span class="pre">y</span></code> 和回车键继续：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>Stopping with channel &#39;mychannel&#39; and CLI timeout of &#39;10&#39;
Continue? [Y/n] y
proceeding ...
WARNING: The CHANNEL_NAME variable is not set. Defaulting to a blank string.
WARNING: The TIMEOUT variable is not set. Defaulting to a blank string.
Removing network net_byfn
468aaa6201ed
...
Untagged: dev-peer1.org2.example.com-mycc-1.0:latest
Deleted: sha256:ed3230614e64e1c83e510c0c282e982d2b06d148b1c498bbdcc429e2b2531e91
...
</pre></div>
</div>
<p>If you’d like to learn more about the underlying tooling and bootstrap mechanics,
continue reading.  In these next sections we’ll walk through the various steps
and requirements to build a fully-functional Hyperledger Fabric network.</p>
<p>如果你打算了解更多底层工具和引导机制的相关信息，请继续阅读下面的章节。在接下来的部分中，我们将介绍构建完整功能 Hyperledger Fabric 网络的各个步骤和相关要求。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The manual steps outlined below assume that the <code class="docutils literal notranslate"><span class="pre">CORE_LOGGING_LEVEL</span></code> in
the <code class="docutils literal notranslate"><span class="pre">cli</span></code> container is set to <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>. You can set this by modifying
the <code class="docutils literal notranslate"><span class="pre">docker-compose-cli.yaml</span></code> file in the <code class="docutils literal notranslate"><span class="pre">first-network</span></code> directory.
e.g.</p>
<p>随后的手动步骤假设 <code class="docutils literal notranslate"><span class="pre">cli</span></code> 容器中的 <code class="docutils literal notranslate"><span class="pre">CORE_LOGGING_LEVEL</span></code> 被设置为 <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>。
你可以通过修改 <code class="docutils literal notranslate"><span class="pre">first-network</span></code> 目录下的 <code class="docutils literal notranslate"><span class="pre">docker-compose-cli.yaml</span></code>
文件来设置这个参数，如下所示：</p>
<div class="code last highlight-default notranslate"><div class="highlight"><pre><span></span>cli:
  container_name: cli
  image: hyperledger/fabric-tools:$IMAGE_TAG
  tty: true
  stdin_open: true
  environment:
    - GOPATH=/opt/gopath
    - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
    - CORE_LOGGING_LEVEL=DEBUG
    #- CORE_LOGGING_LEVEL=INFO
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="crypto-generator">
<h2>Crypto Generator - 加密文件的生成<a class="headerlink" href="#crypto-generator" title="Permalink to this headline">¶</a></h2>
<p>We will use the <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> tool to generate the cryptographic material
(x509 certs and signing keys) for our various network entities.  These certificates are
representative of identities, and they allow for sign/verify authentication to
take place as our entities communicate and transact.</p>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> 工具来为各种网络实体生成加密文件 (x509 证书和密钥)。这些证书代表了身份的标示，网络实体在进行通信和交易的时候，会利用这些证书来进行签名和校验身份。</p>
<div class="section" id="how-does-it-work">
<h3>How does it work? - 它是如何工作的？<a class="headerlink" href="#how-does-it-work" title="Permalink to this headline">¶</a></h3>
<p>Cryptogen consumes a file - <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> - that contains the network
topology and allows us to generate a set of certificates and keys for both the
Organizations and the components that belong to those Organizations.  Each
Organization is provisioned a unique root certificate (<code class="docutils literal notranslate"><span class="pre">ca-cert</span></code>) that binds
specific components (peers and orderers) to that Org.  By assigning each
Organization a unique CA certificate, we are mimicking a typical network where
a participating <a class="reference internal" href="glossary.html#member"><span class="std std-ref">Member - 成员</span></a> would use its own Certificate Authority.
Transactions and communications within Hyperledger Fabric are signed by an
entity’s private key (<code class="docutils literal notranslate"><span class="pre">keystore</span></code>), and then verified by means of a public
key (<code class="docutils literal notranslate"><span class="pre">signcerts</span></code>).</p>
<p>Cryptogen 使用包含了网络拓扑结构的 <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> 配置文件，可以为机构和属于这些机构的组件生成一组证书和密钥。每个机构都配备了一个唯一的根证书（ <code class="docutils literal notranslate"><span class="pre">ca-cert</span></code> ），并将指定的组件（对等节点和排序服务节点）绑定到该机构上。通过为每个机构分配一个唯一的 CA 证书，我们正在模拟一个典型的网络，其中每个指定的 <a class="reference internal" href="glossary.html#member"><span class="std std-ref">Member - 成员</span></a> 将使用自己的 CA 证书颁发机构。Hyperledger Fabric 中的交易和通信，都将由实体的密钥（ <code class="docutils literal notranslate"><span class="pre">keystore</span></code> ）进行签名，然后通过公钥（ <code class="docutils literal notranslate"><span class="pre">signcerts</span></code> ）进行校验。</p>
<p>You will notice a <code class="docutils literal notranslate"><span class="pre">count</span></code> variable within this file.  We use this to specify
the number of peers per Organization; in our case there are two peers per Org.
We won’t delve into the minutiae of <a class="reference external" href="https://en.wikipedia.org/wiki/Public_key_infrastructure">x.509 certificates and public key
infrastructure</a>
right now. If you’re interested, you can peruse these topics on your own time.</p>
<p>你会注意到该文件中的 <code class="docutils literal notranslate"><span class="pre">count</span></code> 变量。我们用这个变量来指定每个机构中对等节点的数量。在我们的示例中，每个机构有两个对等节点。我们现在不会深入研究 <a class="reference external" href="https://en.wikipedia.org/wiki/Public_key_infrastructure">x.509 证书和公钥基础设施</a> 的细节。如果你有兴趣，可以自己找时间来仔细阅读这些资料。</p>
<p>Before running the tool, let’s take a quick look at a snippet from the
<code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code>. Pay specific attention to the “Name”, “Domain”
and “Specs” parameters under the <code class="docutils literal notranslate"><span class="pre">OrdererOrgs</span></code> header:</p>
<p>在运行该工具之前，让我们快速浏览一下 <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> 中的部分配置。请特别注意 <code class="docutils literal notranslate"><span class="pre">OrdererOrgs</span></code> 标题下的 “Name” ， “Domain” 和 “Specs” 参数：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OrdererOrgs</span><span class="p">:</span>
<span class="c1">#---------------------------------------------------------</span>
<span class="c1"># Orderer</span>
<span class="c1"># --------------------------------------------------------</span>
<span class="o">-</span> <span class="n">Name</span><span class="p">:</span> <span class="n">Orderer</span>
  <span class="n">Domain</span><span class="p">:</span> <span class="n">example</span><span class="o">.</span><span class="n">com</span>
  <span class="n">CA</span><span class="p">:</span>
      <span class="n">Country</span><span class="p">:</span> <span class="n">US</span>
      <span class="n">Province</span><span class="p">:</span> <span class="n">California</span>
      <span class="n">Locality</span><span class="p">:</span> <span class="n">San</span> <span class="n">Francisco</span>
  <span class="c1">#   OrganizationalUnit: Hyperledger Fabric</span>
  <span class="c1">#   StreetAddress: address for org # default nil</span>
  <span class="c1">#   PostalCode: postalCode for org # default nil</span>
  <span class="c1"># ------------------------------------------------------</span>
  <span class="c1"># &quot;Specs&quot; - See PeerOrgs below for complete description</span>
<span class="c1"># -----------------------------------------------------</span>
  <span class="n">Specs</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">Hostname</span><span class="p">:</span> <span class="n">orderer</span>
<span class="c1"># -------------------------------------------------------</span>
<span class="c1"># &quot;PeerOrgs&quot; - Definition of organizations managing peer nodes</span>
 <span class="c1"># ------------------------------------------------------</span>
<span class="n">PeerOrgs</span><span class="p">:</span>
<span class="c1"># -----------------------------------------------------</span>
<span class="c1"># Org1</span>
<span class="c1"># ----------------------------------------------------</span>
<span class="o">-</span> <span class="n">Name</span><span class="p">:</span> <span class="n">Org1</span>
  <span class="n">Domain</span><span class="p">:</span> <span class="n">org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span>
  <span class="n">EnableNodeOUs</span><span class="p">:</span> <span class="n">true</span>
</pre></div>
</div>
<p>The naming convention for a network entity is as follows -
“{{.Hostname}}.{{.Domain}}”.  So using our ordering node as a
reference point, we are left with an ordering node named -
<code class="docutils literal notranslate"><span class="pre">orderer.example.com</span></code> that is tied to an MSP ID of <code class="docutils literal notranslate"><span class="pre">Orderer</span></code>.  This file
contains extensive documentation on the definitions and syntax.  You can also
refer to the <a class="reference internal" href="msp.html"><span class="doc">Membership Service Providers (MSP)</span></a> documentation for a deeper dive on MSP.</p>
<p>网络实体的命名约定如下 - “{{.Hostname}}.{{.Domain}}” 。因此，以我们的排序服务节点为例，我们设置了一个名为 - <code class="docutils literal notranslate"><span class="pre">orderer.example.com</span></code> 的排序服务节点，该排序服务节点绑定到名为 <code class="docutils literal notranslate"><span class="pre">Orderer</span></code> 的 MSP ID 上。本文档还包含了有关定义和语法的大量描述，你也可以参阅 <a class="reference internal" href="msp.html"><span class="doc">Membership Service Providers (MSP)</span></a> 文档，以深入了解 MSP。</p>
<p>After we run the <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> tool, the generated certificates and keys will be
saved to a folder titled <code class="docutils literal notranslate"><span class="pre">crypto-config</span></code>.</p>
<p>运行 <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> 工具后，生成的证书和密钥将被保存到 <code class="docutils literal notranslate"><span class="pre">crypto-config</span></code> 文件夹中。</p>
</div>
</div>
<div class="section" id="configuration-transaction-generator">
<h2>Configuration Transaction Generator - 配置交易的生成<a class="headerlink" href="#configuration-transaction-generator" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">configtxgen</span> <span class="pre">tool</span></code> is used to create four configuration artifacts:</p>
<p><code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> 工具用于创建以下四个配置工件：</p>
<blockquote>
<div><ul class="simple">
<li>orderer <code class="docutils literal notranslate"><span class="pre">genesis</span> <span class="pre">block</span></code>,</li>
<li>channel <code class="docutils literal notranslate"><span class="pre">configuration</span> <span class="pre">transaction</span></code>,</li>
<li>and two <code class="docutils literal notranslate"><span class="pre">anchor</span> <span class="pre">peer</span> <span class="pre">transactions</span></code> - one for each Peer Org.</li>
<li>排序服务节点的 <code class="docutils literal notranslate"><span class="pre">初始区块(genesis</span> <span class="pre">block)</span></code></li>
<li>通道的 <code class="docutils literal notranslate"><span class="pre">配置交易(configuration</span> <span class="pre">transaction)</span></code></li>
<li>以及两笔 <code class="docutils literal notranslate"><span class="pre">锚节点交易(anchor</span> <span class="pre">peer</span> <span class="pre">transactions)</span></code> - 每笔对应一个机构</li>
</ul>
</div></blockquote>
<p>Please see <span class="xref std std-doc">configtxgen</span> for a complete description of this tool’s functionality.</p>
<p>请参阅 <span class="xref std std-doc">configtxgen</span> 获取本工具功能的完整描述。</p>
<p>The orderer block is the <a class="reference internal" href="glossary.html#genesis-block"><span class="std std-ref">Genesis Block - 初始区块</span></a> for the ordering service, and the
channel configuration transaction file is broadcast to the orderer at <a class="reference internal" href="glossary.html#channel"><span class="std std-ref">Channel - 通道</span></a> creation
time.  The anchor peer transactions, as the name might suggest, specify each
Org’s <a class="reference internal" href="glossary.html#anchor-peer"><span class="std std-ref">Anchor Peer - 锚节点</span></a> on this channel.</p>
<p>排序服务节点区块是排序服务的 <a class="reference internal" href="glossary.html#genesis-block"><span class="std std-ref">Genesis Block - 初始区块</span></a> ，通道配置交易在创建 <a class="reference internal" href="glossary.html#channel"><span class="std std-ref">Channel - 通道</span></a> 时广播给排序服务节点。 锚节点交易（正如名字所描述的一样）指定了通道中每个机构的 <a class="reference internal" href="glossary.html#anchor-peer"><span class="std std-ref">Anchor Peer - 锚节点</span></a> 。</p>
<div class="section" id="id1">
<h3>How does it work? - 它是如何工作的？<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Configtxgen consumes a file - <code class="docutils literal notranslate"><span class="pre">configtx.yaml</span></code> - that contains the definitions
for the sample network. There are three members - one Orderer Org (<code class="docutils literal notranslate"><span class="pre">OrdererOrg</span></code>)
and two Peer Orgs (<code class="docutils literal notranslate"><span class="pre">Org1</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">Org2</span></code>) each managing and maintaining two peer nodes.
This file also specifies a consortium - <code class="docutils literal notranslate"><span class="pre">SampleConsortium</span></code> - consisting of our
two Peer Orgs.  Pay specific attention to the “Profiles” section at the top of
this file.  You will notice that we have two unique headers. One for the orderer genesis
block - <code class="docutils literal notranslate"><span class="pre">TwoOrgsOrdererGenesis</span></code> - and one for our channel - <code class="docutils literal notranslate"><span class="pre">TwoOrgsChannel</span></code>.</p>
<p>Configtxgen 使用包含了示例网络定义的配置文件 <code class="docutils literal notranslate"><span class="pre">configtx.yaml</span></code>。该文件中定义了示例网络的三个成员 - 一个排序服务节点机构 (<code class="docutils literal notranslate"><span class="pre">OrdererOrg</span></code>) 和两个对等节点机构 (<code class="docutils literal notranslate"><span class="pre">Org1</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">Org2</span></code>)，其中每个对等节点机构管理和维护两个对等节点。该文件还指定了由两个对等节点机构组成的联盟 <code class="docutils literal notranslate"><span class="pre">SampleConsortium</span></code>。请特别注意文件顶部的 “Profiles” 部分。你会注意到有两个特别的部分，一个是排序节点初始区块 <code class="docutils literal notranslate"><span class="pre">TwoOrgsOrdererGenesis</span></code>，另一个是通道配置 <code class="docutils literal notranslate"><span class="pre">TwoOrgsChannel</span></code>。</p>
<p>These headers are important, as we will pass them in as arguments when we create
our artifacts.</p>
<p>上述两个配置参数很重要，在创建配置工件时，将会把它们作为参数传入。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Notice that our <code class="docutils literal notranslate"><span class="pre">SampleConsortium</span></code> is defined in
the system-level profile and then referenced by
our channel-level profile.  Channels exist within
the purview of a consortium, and all consortia
must be defined in the scope of the network at
large.</p>
<p class="last">请注意，我们的 <code class="docutils literal notranslate"><span class="pre">SampleConsortium</span></code> 是在系统级配置文件中定义的，然后在通道级配置文件中被引用。通道存在于一个联盟的范围内，所有联盟都必须在整个网络范围内进行界定。</p>
</div>
<p>This file also contains two additional specifications that are worth
noting. Firstly, we specify the anchor peers for each Peer Org
(<code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>).  Secondly, we point to
the location of the MSP directory for each member, in turn allowing us to store the
root certificates for each Org in the orderer genesis block.  This is a critical
concept. Now any network entity communicating with the ordering service can have
its digital signature verified.</p>
<p>该文件还有两处值得引起注意。第一，我们为每个对等节点机构指定了锚节点(anchor peer)。第二，我们为每个成员指定了 MSP 目录的位置，这使得我们可以在排序服务节点初始区块中保存每个机构的根证书。这是一个非常重要的概念，这样任何与排序服务通信的网络实体都可以校验数字签名了。</p>
</div>
</div>
<div class="section" id="run-the-tools">
<h2>Run the tools - 运行工具<a class="headerlink" href="#run-the-tools" title="Permalink to this headline">¶</a></h2>
<p>You can manually generate the certificates/keys and the various configuration
artifacts using the <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> and <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> commands. Alternately,
you could try to adapt the byfn.sh script to accomplish your objectives.</p>
<p>你可以使用 <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> 命令手动生成证书、密钥以及各种配置工件。此外，你还可以尝试修改 byfn.sh 脚本来达到同样的目的。</p>
<div class="section" id="manually-generate-the-artifacts">
<h3>Manually generate the artifacts - 手动生成<a class="headerlink" href="#manually-generate-the-artifacts" title="Permalink to this headline">¶</a></h3>
<p>You can refer to the <code class="docutils literal notranslate"><span class="pre">generateCerts</span></code> function in the byfn.sh script for the
commands necessary to generate the certificates that will be used for your
network configuration as defined in the <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> file. However,
for the sake of convenience, we will also provide a reference here.</p>
<p>你可以参考 byfn.sh 脚本中 <code class="docutils literal notranslate"><span class="pre">generateCerts</span></code> 函数中的命令，生成 <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> 文件中所使用到的证书文件。当然，为方便起见，我们这里也提供了一个参考方法。</p>
<p>First let’s run the <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> tool.  Our binary is in the <code class="docutils literal notranslate"><span class="pre">bin</span></code>
directory, so we need to provide the relative path to where the tool resides.</p>
<p>首先，运行 <code class="docutils literal notranslate"><span class="pre">cryptogen</span></code> 工具。我们的可执行文件在 <code class="docutils literal notranslate"><span class="pre">bin</span></code> 目录下，所以我们需要提供指向工具的相对路径。</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">../</span><span class="nb">bin</span><span class="o">/</span><span class="n">cryptogen</span> <span class="n">generate</span> <span class="o">--</span><span class="n">config</span><span class="o">=./</span><span class="n">crypto</span><span class="o">-</span><span class="n">config</span><span class="o">.</span><span class="n">yaml</span>
</pre></div>
</div>
<p>You should see the following in your terminal:</p>
<p>你会在终端中看到如下信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span>
<span class="n">org2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span>
</pre></div>
</div>
<p>The certs and keys (i.e. the MSP material) will be output into a directory - <code class="docutils literal notranslate"><span class="pre">crypto-config</span></code> -
at the root of the <code class="docutils literal notranslate"><span class="pre">first-network</span></code> directory.</p>
<p>证书和密钥（例如 MSP 材料）等文件生成后，位于 <code class="docutils literal notranslate"><span class="pre">first-network</span></code> 目录的 <code class="docutils literal notranslate"><span class="pre">crypto-config</span></code> 子目录下。</p>
<p>Next, we need to tell the <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> tool where to look for the
<code class="docutils literal notranslate"><span class="pre">configtx.yaml</span></code> file that it needs to ingest.  We will tell it look in our
present working directory:</p>
<p>随后，我们需要告诉 <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> 工具，在哪个目录下查找它所需要的配置文件 <code class="docutils literal notranslate"><span class="pre">configtx.yaml</span></code> 文件。我们会告诉它在当前的目录中查找：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>export FABRIC_CFG_PATH=$PWD
</pre></div>
</div>
<p>Then, we’ll invoke the <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> tool to create the orderer genesis block:</p>
<p>接着，我们将调用 <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> 工具来创建排序节点初始区块 (the orderer genesis block)：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">../</span><span class="nb">bin</span><span class="o">/</span><span class="n">configtxgen</span> <span class="o">-</span><span class="n">profile</span> <span class="n">TwoOrgsOrdererGenesis</span> <span class="o">-</span><span class="n">outputBlock</span> <span class="o">./</span><span class="n">channel</span><span class="o">-</span><span class="n">artifacts</span><span class="o">/</span><span class="n">genesis</span><span class="o">.</span><span class="n">block</span>
</pre></div>
</div>
<p>You should see an output similar to the following in your terminal:</p>
<p>你会在终端中看到类似如下的信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">26</span> <span class="mi">19</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mf">56.301</span> <span class="n">EDT</span> <span class="p">[</span><span class="n">common</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">configtxgen</span><span class="p">]</span> <span class="n">main</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">001</span> <span class="n">Loading</span> <span class="n">configuration</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">26</span> <span class="mi">19</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mf">56.309</span> <span class="n">EDT</span> <span class="p">[</span><span class="n">common</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">configtxgen</span><span class="p">]</span> <span class="n">doOutputBlock</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">002</span> <span class="n">Generating</span> <span class="n">genesis</span> <span class="n">block</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">26</span> <span class="mi">19</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mf">56.309</span> <span class="n">EDT</span> <span class="p">[</span><span class="n">common</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">configtxgen</span><span class="p">]</span> <span class="n">doOutputBlock</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">003</span> <span class="n">Writing</span> <span class="n">genesis</span> <span class="n">block</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The orderer genesis block and the subsequent artifacts we are about to create
will be output into the <code class="docutils literal notranslate"><span class="pre">channel-artifacts</span></code> directory at the root of this
project.</p>
<p class="last">排序服务节点初始区块以及随后我们生成的配置工件，都保存在本项目根目录下的 <code class="docutils literal notranslate"><span class="pre">channel-artifacts</span></code> 子目录下</p>
</div>
</div>
<div class="section" id="create-a-channel-configuration-transaction">
<span id="createchanneltx"></span><h3>Create a Channel Configuration Transaction - 创建通道配置交易<a class="headerlink" href="#create-a-channel-configuration-transaction" title="Permalink to this headline">¶</a></h3>
<p>Next, we need to create the channel transaction artifact. Be sure to replace <code class="docutils literal notranslate"><span class="pre">$CHANNEL_NAME</span></code> or
set <code class="docutils literal notranslate"><span class="pre">CHANNEL_NAME</span></code> as an environment variable that can be used throughout these instructions:</p>
<p>下一步，我们需要创建通道配置交易。在如下的说明中，请确认已经替换命令中的 <code class="docutils literal notranslate"><span class="pre">$CHANNEL_NAME</span></code> 为实际的通道名称，或者将环境变量 <code class="docutils literal notranslate"><span class="pre">CHANNEL_NAME</span></code> 设置为实际的通道名称 ：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># The channel.tx artifact contains the definitions for our sample channel

# channel.tx 文件中包含了我们示例通道的配置信息

export CHANNEL_NAME=mychannel  &amp;&amp; ../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME
</pre></div>
</div>
<p>You should see an ouput similar to the following in your terminal:</p>
<p>你会在终端中看到类似如下的信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">26</span> <span class="mi">19</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mf">05.324</span> <span class="n">EDT</span> <span class="p">[</span><span class="n">common</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">configtxgen</span><span class="p">]</span> <span class="n">main</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">001</span> <span class="n">Loading</span> <span class="n">configuration</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">26</span> <span class="mi">19</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mf">05.329</span> <span class="n">EDT</span> <span class="p">[</span><span class="n">common</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">configtxgen</span><span class="p">]</span> <span class="n">doOutputChannelCreateTx</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">002</span> <span class="n">Generating</span> <span class="n">new</span> <span class="n">channel</span> <span class="n">configtx</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">26</span> <span class="mi">19</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mf">05.329</span> <span class="n">EDT</span> <span class="p">[</span><span class="n">common</span><span class="o">/</span><span class="n">tools</span><span class="o">/</span><span class="n">configtxgen</span><span class="p">]</span> <span class="n">doOutputChannelCreateTx</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">003</span> <span class="n">Writing</span> <span class="n">new</span> <span class="n">channel</span> <span class="n">tx</span>
</pre></div>
</div>
<p>Next, we will define the anchor peer for Org1 on the channel that we are
constructing. Again, be sure to replace <code class="docutils literal notranslate"><span class="pre">$CHANNEL_NAME</span></code> or set the environment variable
for the following commands.  The terminal output will mimic that of the channel transaction artifact:</p>
<p>接着，我们会指定机构 Org1 的锚节点。再一次注意，请确保替换命令中的 <code class="docutils literal notranslate"><span class="pre">$CHANNEL_NAME</span></code> 为实际的通道名称，或者将环境变量 <code class="docutils literal notranslate"><span class="pre">CHANNEL_NAME</span></code> 设置为实际的通道名称。 终端中会显示出通道交易工件：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
</pre></div>
</div>
<p>Now, we will define the anchor peer for Org2 on the same channel:</p>
<p>现在，我们接着指定机构 Org2 的锚节点：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP
</pre></div>
</div>
</div>
</div>
<div class="section" id="start-the-network">
<h2>Start the network - 启动网络<a class="headerlink" href="#start-the-network" title="Permalink to this headline">¶</a></h2>
<p>We will leverage a script to spin up our network. The
docker-compose file references the images that we have previously downloaded,
and bootstraps the orderer with our previously generated <code class="docutils literal notranslate"><span class="pre">genesis.block</span></code>.</p>
<p>我们会使用一个脚本来启动我们的网络。docker-compose 文件引用了之前我们已经下载好的镜像文件，启动了一个排序服务节点，该排序服务节点使用的是前文生成的 <code class="docutils literal notranslate"><span class="pre">genesis.block</span></code> 。</p>
<p>We want to go through the commands manually in order to expose the
syntax and functionality of each call.</p>
<p>我们希望手动输入一遍所有命令，以便了解每个调用的语法和功能。</p>
<p>First let’s start your network:</p>
<p>首先，让我们启动网络：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span><span class="o">-</span><span class="n">compose</span> <span class="o">-</span><span class="n">f</span> <span class="n">docker</span><span class="o">-</span><span class="n">compose</span><span class="o">-</span><span class="n">cli</span><span class="o">.</span><span class="n">yaml</span> <span class="n">up</span> <span class="o">-</span><span class="n">d</span>
</pre></div>
</div>
<p>If you want to see the realtime logs for your network, then do not supply the <code class="docutils literal notranslate"><span class="pre">-d</span></code> flag.
If you let the logs stream, then you will need to open a second terminal to execute the CLI calls.</p>
<p>如果你希望看到网络的实时输出，请不要添加 <code class="docutils literal notranslate"><span class="pre">-d</span></code> 参数。此时，日志将会持续打印，你需要打开另一个终端来执行 CLI 调用。</p>
<p>The CLI container will stick around idle for 1000 seconds. If it’s gone when you need it you can restart it with a simple command:</p>
<p>CLI 容器会持续闲置等待 1000 秒。如果该容器被关闭，可以使用如下命令重启：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">start</span> <span class="n">cli</span>
</pre></div>
</div>
<div class="section" id="environment-variables">
<span id="peerenvvars"></span><h3>Environment variables - 环境变量<a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h3>
<p>For the following CLI commands against <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> to work, we need
to preface our commands with the four environment variables given below.  These
variables for <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> are baked into the CLI container,
therefore we can operate without passing them.  <strong>HOWEVER</strong>, if you want to send
calls to other peers or the orderer, then you will need to provide these
values accordingly.  Inspect the <code class="docutils literal notranslate"><span class="pre">docker-compose-base.yaml</span></code> for the specific
paths:</p>
<p>随后的 CLI 命令是针对 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 的，在执行命令前，我们需要先设置 4 个环境变量。这些针对 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 的环境变量在 CLI 容器已经被预设好，因此我们此时也可以不设置这些环境变量。<strong>但是</strong>，如果需要调用其他的对等节点或者是排序服务节点，必须设置好相应的环境变量。查看 <code class="docutils literal notranslate"><span class="pre">docker-compose-base.yaml</span></code> 文件可以看到具体的路径：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Environment variables for PEER0</span>

<span class="c1"># 针对 PEER0 的环境变量</span>

<span class="n">CORE_PEER_MSPCONFIGPATH</span><span class="o">=/</span><span class="n">opt</span><span class="o">/</span><span class="n">gopath</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">fabric</span><span class="o">/</span><span class="n">peer</span><span class="o">/</span><span class="n">crypto</span><span class="o">/</span><span class="n">peerOrganizations</span><span class="o">/</span><span class="n">org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="n">Admin</span><span class="nd">@org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">msp</span>
<span class="n">CORE_PEER_ADDRESS</span><span class="o">=</span><span class="n">peer0</span><span class="o">.</span><span class="n">org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">7051</span>
<span class="n">CORE_PEER_LOCALMSPID</span><span class="o">=</span><span class="s2">&quot;Org1MSP&quot;</span>
<span class="n">CORE_PEER_TLS_ROOTCERT_FILE</span><span class="o">=/</span><span class="n">opt</span><span class="o">/</span><span class="n">gopath</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">fabric</span><span class="o">/</span><span class="n">peer</span><span class="o">/</span><span class="n">crypto</span><span class="o">/</span><span class="n">peerOrganizations</span><span class="o">/</span><span class="n">org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">peers</span><span class="o">/</span><span class="n">peer0</span><span class="o">.</span><span class="n">org1</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">tls</span><span class="o">/</span><span class="n">ca</span><span class="o">.</span><span class="n">crt</span>
</pre></div>
</div>
</div>
<div class="section" id="create-join-channel">
<span id="createandjoin"></span><h3>Create &amp; Join Channel - 创建和加入通道<a class="headerlink" href="#create-join-channel" title="Permalink to this headline">¶</a></h3>
<p>Recall that we created the channel configuration transaction using the
<code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> tool in the <a class="reference internal" href="#createchanneltx"><span class="std std-ref">Create a Channel Configuration Transaction - 创建通道配置交易</span></a> section, above. You can
repeat that process to create additional channel configuration transactions,
using the same or different profiles in the <code class="docutils literal notranslate"><span class="pre">configtx.yaml</span></code> that you pass
to the <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> tool. Then you can repeat the process defined in this
section to establish those other channels in your network.</p>
<p>回忆下，我们在 <a class="reference internal" href="#createchanneltx"><span class="std std-ref">Create a Channel Configuration Transaction - 创建通道配置交易</span></a> 一节中使用 <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> 工具生成了通道配置交易。你可以重复上述过程，在使用 <code class="docutils literal notranslate"><span class="pre">configtxgen</span></code> 工具时使用和之前 <code class="docutils literal notranslate"><span class="pre">configtx.yaml</span></code> 文件中相同或者不同的配置，生成新的通道配置交易。随后，你可以重复本节所提的过程，在网络中创建其他的通道。</p>
<p>We will enter the CLI container using the <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code> command:</p>
<p>我们使用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code> 命令进入 CLI 容器内：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">exec</span> <span class="o">-</span><span class="n">it</span> <span class="n">cli</span> <span class="n">bash</span>
</pre></div>
</div>
<p>If successful you should see the following:</p>
<p>如果成功，你会看到如下信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@0d78bb69300d</span><span class="p">:</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">gopath</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">fabric</span><span class="o">/</span><span class="n">peer</span><span class="c1">#</span>
</pre></div>
</div>
<p>Next, we are going to pass in the generated channel configuration transaction
artifact that we created in the <a class="reference internal" href="#createchanneltx"><span class="std std-ref">Create a Channel Configuration Transaction - 创建通道配置交易</span></a> section (we called
it <code class="docutils literal notranslate"><span class="pre">channel.tx</span></code>) to the orderer as part of the create channel request.</p>
<p>随后，我们会将 <a class="reference internal" href="#createchanneltx"><span class="std std-ref">Create a Channel Configuration Transaction - 创建通道配置交易</span></a> 一节中生成的通道配置交易工件 <code class="docutils literal notranslate"><span class="pre">channel.tx</span></code> 传给排序服务节点，用于创建通道。</p>
<p>We specify our channel name with the <code class="docutils literal notranslate"><span class="pre">-c</span></code> flag and our channel configuration
transaction with the <code class="docutils literal notranslate"><span class="pre">-f</span></code> flag. In this case it is <code class="docutils literal notranslate"><span class="pre">channel.tx</span></code>, however
you can mount your own configuration transaction with a different name.  Once again
we will set the <code class="docutils literal notranslate"><span class="pre">CHANNEL_NAME</span></code> environment variable within our CLI container so that
we don’t have to explicitly pass this argument:</p>
<p>我们可以使用 <code class="docutils literal notranslate"><span class="pre">-c</span></code> 参数指定我们的通道名称，以及使用 <code class="docutils literal notranslate"><span class="pre">-f</span></code> 参数指定通道配置交易工件。在本示例中，通道配置交易工件是 <code class="docutils literal notranslate"><span class="pre">channel.tx</span></code>，当然，你可以使用自己生成的任意名字的通道配置交易工件。再一次提醒，我们需要在 CLI 容器中设置环境变量 <code class="docutils literal notranslate"><span class="pre">CHANNEL_NAME</span></code>，这样就不必在每次输入命令时再显式的输入该参数：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>export CHANNEL_NAME=mychannel

# the channel.tx file is mounted in the channel-artifacts directory within your CLI container
# as a result, we pass the full path for the file
# we also pass the path for the orderer ca-cert in order to verify the TLS handshake
# be sure to export or replace the $CHANNEL_NAME variable appropriately

# channel.tx 文件被挂载在 CLI 容器的 channel-artifacts 目录下
# 因此，我们需要传入该文件的绝对路径
# 同时，我们还传入了用于校验 TLS 握手的排序服务节点的 ca 证书
# 请确保设置了环境变量 $CHANNEL_NAME，或者将命令中的 $CHANNEL_NAME 修改为实际值

peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Notice the <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">cafile</span></code> that we pass as part of this command.  It is
the local path to the orderer’s root cert, allowing us to verify the
TLS handshake.</p>
<p class="last">请注意命令中的 <code class="docutils literal notranslate"><span class="pre">--</span> <span class="pre">cafile</span></code> 参数，它指向了排序服务节点的根证书，用于完成 TLS 握手的校验。</p>
</div>
<p>This command returns a genesis block - <code class="docutils literal notranslate"><span class="pre">&lt;channel-ID.block&gt;</span></code> - which we will use to join the channel.
It contains the configuration information specified in <code class="docutils literal notranslate"><span class="pre">channel.tx</span></code>  If you have not
made any modifications to the default channel name, then the command will return you a
proto titled <code class="docutils literal notranslate"><span class="pre">mychannel.block</span></code>.</p>
<p>该命令返回一个初始区块 <code class="docutils literal notranslate"><span class="pre">&lt;channel-ID.block&gt;</span></code>，我们使用它来加入通道。它包含了 <code class="docutils literal notranslate"><span class="pre">channel.tx</span></code> 中指定的配置信息。如果你没有修改默认的通道名称，该命令会返回名为 <code class="docutils literal notranslate"><span class="pre">mychannel.block</span></code> 的文件。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You will remain in the CLI container for the remainder of
these manual commands. You must also remember to preface all commands
with the corresponding environment variables when targeting a peer other than
<code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>.</p>
<p class="last">随后手动执行的命令，都需要在 CLI 容器内执行。同时需要注意，如果希望连接除 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 外的其他对等节点，需要将环境变量设置为相应的值。</p>
</div>
<p>Now let’s join <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> to the channel.</p>
<p>现在，让我们把 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 加入到通道中。</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># By default, this joins ``peer0.org1.example.com`` only</span>
<span class="c1"># the &lt;channel-ID.block&gt; was returned by the previous command</span>
<span class="c1"># if you have not modified the channel name, you will join with mychannel.block</span>
<span class="c1"># if you have created a different channel name, then pass in the appropriately named block</span>

<span class="c1"># 下述命令默认将 ``peer0.org1.example.com`` 加入 mychannel.block 对应的通道中</span>
<span class="c1"># 如果你修改了通道名称，请传入相应的 .block 文件名</span>

 <span class="n">peer</span> <span class="n">channel</span> <span class="n">join</span> <span class="o">-</span><span class="n">b</span> <span class="n">mychannel</span><span class="o">.</span><span class="n">block</span>
</pre></div>
</div>
<p>You can make other peers join the channel as necessary by making appropriate
changes in the four environment variables we used in the <a class="reference internal" href="#peerenvvars"><span class="std std-ref">Environment variables - 环境变量</span></a>
section, above.</p>
<p>通过修改 <a class="reference internal" href="#peerenvvars"><span class="std std-ref">Environment variables - 环境变量</span></a> 节中的环境变量为相应的值，你可以将所需要的对等节点都加入到通道中。</p>
<p>Rather than join every peer, we will simply join <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> so that
we can properly update the anchor peer definitions in our channel.  Since we are
overriding the default environment variables baked into the CLI container, this full
command will be the following:</p>
<p>我们并不添加所有的对等节点到该通道中，我们只添加 <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> ，这样我们就可以更新通道的锚节点信息。我们需要覆盖 CLI 容器中的默认环境变量，完整的命令如下：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CORE_PEER_MSPCONFIGPATH</span><span class="o">=/</span><span class="n">opt</span><span class="o">/</span><span class="n">gopath</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">fabric</span><span class="o">/</span><span class="n">peer</span><span class="o">/</span><span class="n">crypto</span><span class="o">/</span><span class="n">peerOrganizations</span><span class="o">/</span><span class="n">org2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="n">Admin</span><span class="nd">@org2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">msp</span> <span class="n">CORE_PEER_ADDRESS</span><span class="o">=</span><span class="n">peer0</span><span class="o">.</span><span class="n">org2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="p">:</span><span class="mi">7051</span> <span class="n">CORE_PEER_LOCALMSPID</span><span class="o">=</span><span class="s2">&quot;Org2MSP&quot;</span> <span class="n">CORE_PEER_TLS_ROOTCERT_FILE</span><span class="o">=/</span><span class="n">opt</span><span class="o">/</span><span class="n">gopath</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">fabric</span><span class="o">/</span><span class="n">peer</span><span class="o">/</span><span class="n">crypto</span><span class="o">/</span><span class="n">peerOrganizations</span><span class="o">/</span><span class="n">org2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">peers</span><span class="o">/</span><span class="n">peer0</span><span class="o">.</span><span class="n">org2</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">tls</span><span class="o">/</span><span class="n">ca</span><span class="o">.</span><span class="n">crt</span> <span class="n">peer</span> <span class="n">channel</span> <span class="n">join</span> <span class="o">-</span><span class="n">b</span> <span class="n">mychannel</span><span class="o">.</span><span class="n">block</span>
</pre></div>
</div>
<p>Alternatively, you could choose to set these environment variables individually
rather than passing in the entire string.  Once they’ve been set, you simply need
to issue the <code class="docutils literal notranslate"><span class="pre">peer</span> <span class="pre">channel</span> <span class="pre">join</span></code> command again and the CLI container will act
on behalf of <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>.</p>
<p>另一种方式，你还可以选择单独设置这些环境变量，而不必在执行命令时传入整个设置串。一旦设置好这些环境变量，你需要执行 <code class="docutils literal notranslate"><span class="pre">peer</span> <span class="pre">channel</span> <span class="pre">join</span></code> 命令，此时 CLI 容器会连接 <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> 进行相应操作。</p>
</div>
<div class="section" id="update-the-anchor-peers">
<h3>Update the anchor peers - 更新锚节点<a class="headerlink" href="#update-the-anchor-peers" title="Permalink to this headline">¶</a></h3>
<p>The following commands are channel updates and they will propagate to the definition
of the channel.  In essence, we adding additional configuration information on top
of the channel’s genesis block.  Note that we are not modifying the genesis block, but
simply adding deltas into the chain that will define the anchor peers.</p>
<p>如下的命令用于更新通道，会修改通道的定义。总体而言，我们会在通道的初始区块基础上，增加额外的配置信息。值得注意的是，我们并未修改初始区块，而是在链上增加增量信息，用于定义锚节点。</p>
<p>Update the channel definition to define the anchor peer for Org1 as <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>:</p>
<p>更新通道配置信息，将机构 Org1 的锚节点设置为 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre></div>
</div>
<p>Now update the channel definition to define the anchor peer for Org2 as <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>.
Identically to the <code class="docutils literal notranslate"><span class="pre">peer</span> <span class="pre">channel</span> <span class="pre">join</span></code> command for the Org2 peer, we will need to
preface this call with the appropriate environment variables.</p>
<p>现在，更新通道配置信息，将机构 Org2 的锚节点设置为 <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>。和结构 Org2 节点的 <code class="docutils literal notranslate"><span class="pre">peer</span> <span class="pre">channel</span> <span class="pre">join</span></code> 命令类似，我们需要在此命令前增加相应的环境变量。</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot; CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem
</pre></div>
</div>
</div>
<div class="section" id="install-instantiate-chaincode">
<h3>Install &amp; Instantiate Chaincode - 安装和实例化链码<a class="headerlink" href="#install-instantiate-chaincode" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>We will utilize a simple existing chaincode. To learn how to write
your own chaincode, see the <a class="reference internal" href="chaincode4ade.html"><span class="doc">Chaincode for Developers</span></a> tutorial.</p>
<p class="last">我们会使用一个简单的既有链码。如果想学习如何编写链码，请参考 <a class="reference internal" href="chaincode4ade.html"><span class="doc">Chaincode for Developers</span></a> 教程。</p>
</div>
<p>Applications interact with the blockchain ledger through <code class="docutils literal notranslate"><span class="pre">chaincode</span></code>.  As
such we need to install the chaincode on every peer that will execute and
endorse our transactions, and then instantiate the chaincode on the channel.</p>
<p>应用通过 <code class="docutils literal notranslate"><span class="pre">链码(chaincode)</span></code> 和区块链账本进行交互。因此，我们需要在每个执行交易或为交易背书的对等节点上安装链码，随后在通道中实例化该链码。</p>
<p>First, install the sample Go or Node.js chaincode onto one of the four peer nodes.  These commands
place the specified source code flavor onto our peer’s filesystem.</p>
<p>首先，在 4 个对等节点中的 1 个节点上安装示例的 Go 或者 Node.js 链码。这些命令指定了对等节点文件系统上的源码路径。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You can only install one version of the source code per chaincode name
and version.  The source code exists on the peer’s file system in the
context of chaincode name and version; it is language agnostic.  Similarly
the instantiated chaincode container will be reflective of whichever
language has been installed on the peer.</p>
<p class="last">对于每个链码的每个版本，只允许安装相同的源代码。源文件基于链码名称和版本号保存在对等节点文件系统上，编程语言此时是未知的。类似的，实例化后的链码容器会反映出是哪种编程语言被安装在该对等节点上。</p>
</div>
<p><strong>Golang</strong></p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># this installs the Go chaincode</span>

<span class="c1"># 安装 Go 链码</span>
<span class="n">peer</span> <span class="n">chaincode</span> <span class="n">install</span> <span class="o">-</span><span class="n">n</span> <span class="n">mycc</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.0</span> <span class="o">-</span><span class="n">p</span> <span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">chaincode</span><span class="o">/</span><span class="n">chaincode_example02</span><span class="o">/</span><span class="n">go</span><span class="o">/</span>
</pre></div>
</div>
<p><strong>Node.js</strong></p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># this installs the Node.js chaincode</span>
<span class="c1"># make note of the -l flag; we use this to specify the language</span>

<span class="c1"># 安装 Node.js 链码</span>
<span class="c1"># 注意 -l 参数，我们使用它来指定编程语言</span>
<span class="n">peer</span> <span class="n">chaincode</span> <span class="n">install</span> <span class="o">-</span><span class="n">n</span> <span class="n">mycc</span> <span class="o">-</span><span class="n">v</span> <span class="mf">1.0</span> <span class="o">-</span><span class="n">l</span> <span class="n">node</span> <span class="o">-</span><span class="n">p</span> <span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">gopath</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">chaincode</span><span class="o">/</span><span class="n">chaincode_example02</span><span class="o">/</span><span class="n">node</span><span class="o">/</span>
</pre></div>
</div>
<p>Next, instantiate the chaincode on the channel. This will initialize the
chaincode on the channel, set the endorsement policy for the chaincode, and
launch a chaincode container for the targeted peer.  Take note of the <code class="docutils literal notranslate"><span class="pre">-P</span></code>
argument. This is our policy where we specify the required level of endorsement
for a transaction against this chaincode to be validated.</p>
<p>下一步，实例化通道中的链码，即初始化通道中的链码、设置链码的背书策略以及为每个目标对等节点启动一个链码容器。注意 <code class="docutils literal notranslate"><span class="pre">-P</span></code> 参数，这是我们指定的背书策略级别，用于校验链码的交易。</p>
<p>In the command below you’ll notice that we specify our policy as
<code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">&quot;OR</span> <span class="pre">('Org0MSP.peer','Org1MSP.peer')&quot;</span></code>. This means that we need
“endorsement” from a peer belonging to Org1 <strong>OR</strong> Org2 (i.e. only one endorsement).
If we changed the syntax to <code class="docutils literal notranslate"><span class="pre">AND</span></code> then we would need two endorsements.</p>
<p>在下面的命令中，你可以看到我们指定的策略为 <code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">&quot;OR</span> <span class="pre">('Org0MSP.peer','Org1MSP.peer')&quot;</span></code>。这表示我们需要机构 Org1 <strong>或者</strong> 机构 Org2 中一个节点的 “背书”（即只需要一个背书）。如果我们将策略改为 <code class="docutils literal notranslate"><span class="pre">AND</span></code>，则我们需要两个背书。</p>
<p><strong>Golang</strong></p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to replace the $CHANNEL_NAME environment variable if you have not exported it
# if you did not install your chaincode with a name of mycc, then modify that argument as well

# 请确保替换了 $CHANNEL_NAME 环境变量，或已经提前设置好
# 如果你安装链码时指定的名称不是 mycc，请修改如下参数为对应值

peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;
</pre></div>
</div>
<p><strong>Node.js</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The instantiation of the Node.js chaincode will take roughly a minute.
The command is not hanging; rather it is installing the fabric-shim
layer as the image is being compiled.</p>
<p class="last">Node.js 链码的实例化会大概耗时 1 分钟。此时命令并没有被挂起，而是在安装 fabric-shim 层以及编译镜像。</p>
</div>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to replace the $CHANNEL_NAME environment variable if you have not exported it
# if you did not install your chaincode with a name of mycc, then modify that argument as well
# notice that we must pass the -l flag after the chaincode name to identify the language

# 请确保替换了 $CHANNEL_NAME 环境变量，或已经提前设置好
# 如果你安装链码时指定的名字不是 mycc，请修改如下参数为对应值
# 注意必须在链码名称后传入 -l 参数来指定链码编程语言

peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -l node -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39; -P &quot;OR (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;
</pre></div>
</div>
<p>See the <a class="reference external" href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">endorsement
policies</a>
documentation for more details on policy implementation.</p>
<p>如果想了解背书策略实现的具体细节，请参考 <a class="reference external" href="http://hyperledger-fabric.readthedocs.io/en/latest/endorsement-policies.html">endorsement
policies</a> 文档。</p>
<p>If you want additional peers to interact with ledger, then you will need to join
them to the channel, and install the same name, version and language of the
chaincode source onto the appropriate peer’s filesystem.  A chaincode container
will be launched for each peer as soon as they try to interact with that specific
chaincode.  Again, be cognizant of the fact that the Node.js images will be slower
to compile.</p>
<p>如果你想让其他节点和账本进行交互，你需要将它们添加到通道中，然后在相应的对等节点文件系统上，安装同名称、同版本以及同编程语言的链码源文件。对于每个对等节点，当它们试图和指定链码进行交互时，会立即启动该链码对应的容器。再一次提醒，Node.js 镜像的编译速度会比较慢。</p>
<p>Once the chaincode has been instantiated on the channel, we can forgo the <code class="docutils literal notranslate"><span class="pre">l</span></code>
flag.  We need only pass in the channel identifier and name of the chaincode.</p>
<p>一旦链码在通道中实例化后，我们可以不再添加 <code class="docutils literal notranslate"><span class="pre">l</span></code> 参数。我们只需要添加通道标识以及链码名称即可。</p>
</div>
<div class="section" id="query">
<h3>Query - 查询<a class="headerlink" href="#query" title="Permalink to this headline">¶</a></h3>
<p>Let’s query for the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> to make sure the chaincode was properly
instantiated and the state DB was populated. The syntax for query is as follows:</p>
<p>让我们通过查询 <code class="docutils literal notranslate"><span class="pre">a</span></code> 对应的值，来确保链码已经被正确的实例化，以及状态数据库 (state DB) 已经被设置好。查询的语法如下：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to set the -C and -n flags appropriately

peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;
</pre></div>
</div>
</div>
<div class="section" id="invoke">
<h3>Invoke - 调用<a class="headerlink" href="#invoke" title="Permalink to this headline">¶</a></h3>
<p>Now let’s move <code class="docutils literal notranslate"><span class="pre">10</span></code> from <code class="docutils literal notranslate"><span class="pre">a</span></code> to <code class="docutils literal notranslate"><span class="pre">b</span></code>.  This transaction will cut a new block and
update the state DB. The syntax for invoke is as follows:</p>
<p>现在让我们从 <code class="docutils literal notranslate"><span class="pre">a</span></code> 转移 <code class="docutils literal notranslate"><span class="pre">10</span></code> 到 <code class="docutils literal notranslate"><span class="pre">b</span></code>。这个交易会生成一个新区块并更新状态数据库。执行的语法如下：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to set the -C and -n flags appropriately

peer chaincode invoke -o orderer.example.com:7050  --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39;
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>Query - 查询<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Let’s confirm that our previous invocation executed properly. We initialized the
key <code class="docutils literal notranslate"><span class="pre">a</span></code> with a value of <code class="docutils literal notranslate"><span class="pre">100</span></code> and just removed <code class="docutils literal notranslate"><span class="pre">10</span></code> with our previous
invocation. Therefore, a query against <code class="docutils literal notranslate"><span class="pre">a</span></code> should reveal <code class="docutils literal notranslate"><span class="pre">90</span></code>. The syntax
for query is as follows.</p>
<p>下面确认我们之前的操作被正确执行了。我们将 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的值初始化为 <code class="docutils literal notranslate"><span class="pre">100</span></code>，然后在上个操作中转移了 <code class="docutils literal notranslate"><span class="pre">10</span></code>。因此，再次查询 <code class="docutils literal notranslate"><span class="pre">a</span></code> 的值应该为 <code class="docutils literal notranslate"><span class="pre">90</span></code>。查询的语法如下：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to set the -C and -n flags appropriately

peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;
</pre></div>
</div>
<p>We should see the following:</p>
<p>我们应该会看到如下信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Query</span> <span class="n">Result</span><span class="p">:</span> <span class="mi">90</span>
</pre></div>
</div>
<p>Feel free to start over and manipulate the key value pairs and subsequent
invocations.</p>
<p>请任意的从头执行本节内容、修改键值以及后续调用。</p>
</div>
<div class="section" id="what-s-happening-behind-the-scenes">
<span id="behind-scenes"></span><h3>What’s happening behind the scenes? - 背后发生了什么？<a class="headerlink" href="#what-s-happening-behind-the-scenes" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>These steps describe the scenario in which
<code class="docutils literal notranslate"><span class="pre">script.sh</span></code> is run by ‘./byfn.sh up’.  Clean your network
with <code class="docutils literal notranslate"><span class="pre">./byfn.sh</span> <span class="pre">down</span></code> and ensure
this command is active.  Then use the same
docker-compose prompt to launch your network again</p>
<p class="last">后续的步骤描述了由 ‘./byfn.sh up’ 启动 <code class="docutils literal notranslate"><span class="pre">script.sh</span></code> 后的场景。使用 <code class="docutils literal notranslate"><span class="pre">./byfn.sh</span> <span class="pre">down</span></code> 清空原先的网络，确保该命令执行成功。随后使用相同的 docker-compose 命令再次启动网络。</p>
</div>
<ul class="simple">
<li>A script - <code class="docutils literal notranslate"><span class="pre">script.sh</span></code> - is baked inside the CLI container. The
script drives the <code class="docutils literal notranslate"><span class="pre">createChannel</span></code> command against the supplied channel name
and uses the channel.tx file for channel configuration.</li>
<li>脚本 - <code class="docutils literal notranslate"><span class="pre">script.sh</span></code> - 包含在 CLI 容器中。该脚本使用提供的通道名调用 <code class="docutils literal notranslate"><span class="pre">createChannel</span></code> 命令，并使用 channel.tx 文件作为通道配置文件。</li>
<li>The output of <code class="docutils literal notranslate"><span class="pre">createChannel</span></code> is a genesis block -
<code class="docutils literal notranslate"><span class="pre">&lt;your_channel_name&gt;.block</span></code> - which gets stored on the peers’ file systems and contains
the channel configuration specified from channel.tx.</li>
<li><code class="docutils literal notranslate"><span class="pre">createChannel</span></code> 的输出是一个初始区块 <code class="docutils literal notranslate"><span class="pre">&lt;your_channel_name&gt;.block</span></code>，该文件保存在对等节点的文件系统下，其中包含了 channel.tx 中指定的通道配置信息。</li>
<li>The <code class="docutils literal notranslate"><span class="pre">joinChannel</span></code> command is exercised for all four peers, which takes as
input the previously generated genesis block.  This command instructs the
peers to join <code class="docutils literal notranslate"><span class="pre">&lt;your_channel_name&gt;</span></code> and create a chain starting with <code class="docutils literal notranslate"><span class="pre">&lt;your_channel_name&gt;.block</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">joinChannel</span></code> 命令以上一步生成的初始区块作为输入，在四个对等节点上都进行了执行。该命令将对等节点加入 <code class="docutils literal notranslate"><span class="pre">&lt;your_channel_name&gt;</span></code> 通道，同时创建了一个基于 <code class="docutils literal notranslate"><span class="pre">&lt;your_channel_name&gt;.block</span></code> 的链。</li>
<li>Now we have a channel consisting of four peers, and two
organizations.  This is our <code class="docutils literal notranslate"><span class="pre">TwoOrgsChannel</span></code> profile.</li>
<li>现在我们拥有一个包含了 2 个结构、4 个对等节点的通道。这就是我们的 <code class="docutils literal notranslate"><span class="pre">TwoOrgsChannel</span></code> 配置。</li>
<li><code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> and <code class="docutils literal notranslate"><span class="pre">peer1.org1.example.com</span></code> belong to Org1;
<code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> and <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code> belong to Org2</li>
<li><code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 和 <code class="docutils literal notranslate"><span class="pre">peer1.org1.example.com</span></code> 属于机构 Org1;
<code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> 和 <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code> 属于机构 Org2</li>
<li>These relationships are defined through the <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> and
the MSP path is specified in our docker compose.</li>
<li>上述关系是在 <code class="docutils literal notranslate"><span class="pre">crypto-config.yaml</span></code> 中进行定义，MSP 路径则是在我们的 docker-compose 配置文件中指定。</li>
<li>The anchor peers for Org1MSP (<code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>) and
Org2MSP (<code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>) are then updated.  We do this by passing
the <code class="docutils literal notranslate"><span class="pre">Org1MSPanchors.tx</span></code> and <code class="docutils literal notranslate"><span class="pre">Org2MSPanchors.tx</span></code> artifacts to the ordering
service along with the name of our channel.</li>
<li>随后更新了 Org1MSP 的锚节点 (<code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>) 以及 Org2MSP 的锚节点 (<code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>) 。我们通过将 <code class="docutils literal notranslate"><span class="pre">Org1MSPanchors.tx</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Org2MSPanchors.tx</span></code> 文件提交给排序服务（其中需要指定我们的通道名称）实现了上述更新。</li>
<li>A chaincode - <strong>chaincode_example02</strong> - is installed on <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> and
<code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code></li>
<li>一个链码 - <strong>chaincode_example02</strong> - 被安装在 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 和
<code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> 上</li>
<li>The chaincode is then “instantiated” on <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code>. Instantiation
adds the chaincode to the channel, starts the container for the target peer,
and initializes the key value pairs associated with the chaincode.  The initial
values for this example are [“a”,”100” “b”,”200”]. This “instantiation” results
in a container by the name of <code class="docutils literal notranslate"><span class="pre">dev-peer0.org2.example.com-mycc-1.0</span></code> starting.</li>
<li>该链码随后在 <code class="docutils literal notranslate"><span class="pre">peer0.org2.example.com</span></code> 上进行了 “实例化”。实例化的过程中，将该链码添加到通道中、在目标对等节点上启动容器以及初始化了链码中的 key-value 对。本例的初始化值是 [“a”,”100” “b”,”200”]。 “初始化” 过程完成后，一个名为 <code class="docutils literal notranslate"><span class="pre">dev-peer0.org2.example.com-mycc-1.0</span></code> 的容器被启动。</li>
<li>The instantiation also passes in an argument for the endorsement
policy. The policy is defined as
<code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">&quot;OR</span>&#160;&#160;&#160; <span class="pre">('Org1MSP.peer','Org2MSP.peer')&quot;</span></code>, meaning that any
transaction must be endorsed by a peer tied to Org1 or Org2.</li>
<li>实例化过程同时还传入一个参数，作为背书策略。本例中的背书策略是 <code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">&quot;OR</span>&#160;&#160;&#160; <span class="pre">('Org1MSP.peer','Org2MSP.peer')&quot;</span></code>，表示每一次交易都必须由机构 Org1 或者机构 Org2 的对等节点进行背书。</li>
<li>A query against the value of “a” is issued to <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>. The
chaincode was previously installed on <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>, so this will start
a container for Org1 peer0 by the name of <code class="docutils literal notranslate"><span class="pre">dev-peer0.org1.example.com-mycc-1.0</span></code>. The result
of the query is also returned. No write operations have occurred, so
a query against “a” will still return a value of “100”.</li>
<li>向 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 发起了一个查找 “a” 对应值的查询。链码已经在 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 上安装完毕，此时会启动一个名为 <code class="docutils literal notranslate"><span class="pre">dev-peer0.org1.example.com-mycc-1.0</span></code> 的容器（针对机构 Org1 以及对等节点 peer0）。查询的结果随后被返回。此时还没有写入操作发生，所以查询 “a” 值的返回结果为 “100”。</li>
<li>An invoke is sent to <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> to move “10” from “a” to “b”</li>
<li>向 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 发送了一个调用操作，将从 “a” 转移 “10” 给 “b”。</li>
<li>The chaincode is then installed on <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code></li>
<li>随后，链码被安装在 <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code> 上</li>
<li>A query is sent to <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code> for the value of “a”. This starts a
third chaincode container by the name of <code class="docutils literal notranslate"><span class="pre">dev-peer1.org2.example.com-mycc-1.0</span></code>. A
value of 90 is returned, correctly reflecting the previous
transaction during which the value for key “a” was modified by 10.</li>
<li>向 <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code> 发起了一个查找 “a” 对应值的查询。此时会启动第 3 个容器，名为 <code class="docutils literal notranslate"><span class="pre">dev-peer1.org2.example.com-mycc-1.0</span></code>。返回值为 90，正确的反映了之前的交易结果，其中 “a” 对应的值被转移了 “10”。</li>
</ul>
</div>
<div class="section" id="what-does-this-demonstrate">
<h3>What does this demonstrate? - 演示了哪些内容？<a class="headerlink" href="#what-does-this-demonstrate" title="Permalink to this headline">¶</a></h3>
<p>Chaincode <strong>MUST</strong> be installed on a peer in order for it to
successfully perform read/write operations against the ledger.
Furthermore, a chaincode container is not started for a peer until an <code class="docutils literal notranslate"><span class="pre">init</span></code> or
traditional transaction - read/write - is performed against that chaincode (e.g. query for
the value of “a”). The transaction causes the container to start. Also,
all peers in a channel maintain an exact copy of the ledger which
comprises the blockchain to store the immutable, sequenced record in
blocks, as well as a state database to maintain a snapshot of the current state.
This includes those peers that do not have chaincode installed on them
(like <code class="docutils literal notranslate"><span class="pre">peer1.org1.example.com</span></code> in the above example) . Finally, the chaincode is accessible
after it is installed (like <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code> in the above example) because it
has already been instantiated.</p>
<p>链码 <strong>必须</strong> 被安装在对等节点上后，才具备了成功读写账本的能力。进一步的，链码容器只有在 <code class="docutils literal notranslate"><span class="pre">初始化</span> <span class="pre">(init)</span></code> 或者传统读写交易（例如查询 “a” 对应的值）发生时才会启动。 是由交易启动了容器。同时，通道内的所有对等节点各自都维护了账本的一份准确的拷贝，该账本中包含了区块链（用于存储不可变且有序的区块），还包含了状态数据库（用于维护当前状态快照）。并不是每个对等节点都需要安装链码（例如上述例子中的 <code class="docutils literal notranslate"><span class="pre">peer1.org1.example.com</span></code>）。最后，链码如果已经被实例化过一次，
则在新的对等节点上被安装后即可直接被访问（例如上述例子中的 <code class="docutils literal notranslate"><span class="pre">peer1.org2.example.com</span></code>）。</p>
</div>
<div class="section" id="how-do-i-see-these-transactions">
<h3>How do I see these transactions? - 如何查看交易的具体信息？<a class="headerlink" href="#how-do-i-see-these-transactions" title="Permalink to this headline">¶</a></h3>
<p>Check the logs for the CLI Docker container.</p>
<p>查看 CLI Docker 容器的日志。</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">logs</span> <span class="o">-</span><span class="n">f</span> <span class="n">cli</span>
</pre></div>
</div>
<p>You should see the following output:</p>
<p>你会看到如下输出：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">16</span> <span class="mi">17</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">01.366</span> <span class="n">UTC</span> <span class="p">[</span><span class="n">msp</span><span class="p">]</span> <span class="n">GetLocalMSP</span> <span class="o">-&gt;</span> <span class="n">DEBU</span> <span class="mi">004</span> <span class="n">Returning</span> <span class="n">existing</span> <span class="n">local</span> <span class="n">MSP</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">16</span> <span class="mi">17</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">01.366</span> <span class="n">UTC</span> <span class="p">[</span><span class="n">msp</span><span class="p">]</span> <span class="n">GetDefaultSigningIdentity</span> <span class="o">-&gt;</span> <span class="n">DEBU</span> <span class="mi">005</span> <span class="n">Obtaining</span> <span class="n">default</span> <span class="n">signing</span> <span class="n">identity</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">16</span> <span class="mi">17</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">01.366</span> <span class="n">UTC</span> <span class="p">[</span><span class="n">msp</span><span class="o">/</span><span class="n">identity</span><span class="p">]</span> <span class="n">Sign</span> <span class="o">-&gt;</span> <span class="n">DEBU</span> <span class="mi">006</span> <span class="n">Sign</span><span class="p">:</span> <span class="n">plaintext</span><span class="p">:</span> <span class="mi">0</span><span class="n">AB1070A6708031A0C08F1E3ECC80510</span><span class="o">...</span><span class="mi">6</span><span class="n">D7963631A0A0A0571756572790A0161</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">16</span> <span class="mi">17</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">01.367</span> <span class="n">UTC</span> <span class="p">[</span><span class="n">msp</span><span class="o">/</span><span class="n">identity</span><span class="p">]</span> <span class="n">Sign</span> <span class="o">-&gt;</span> <span class="n">DEBU</span> <span class="mi">007</span> <span class="n">Sign</span><span class="p">:</span> <span class="n">digest</span><span class="p">:</span> <span class="n">E61DB37F4E8B0D32C9FE10E3936BA9B8CD278FAA1F3320B08712164248285C54</span>
<span class="n">Query</span> <span class="n">Result</span><span class="p">:</span> <span class="mi">90</span>
<span class="mi">2017</span><span class="o">-</span><span class="mi">05</span><span class="o">-</span><span class="mi">16</span> <span class="mi">17</span><span class="p">:</span><span class="mi">08</span><span class="p">:</span><span class="mf">15.158</span> <span class="n">UTC</span> <span class="p">[</span><span class="n">main</span><span class="p">]</span> <span class="n">main</span> <span class="o">-&gt;</span> <span class="n">INFO</span> <span class="mi">008</span> <span class="n">Exiting</span><span class="o">.....</span>
<span class="o">=====================</span> <span class="n">Query</span> <span class="n">on</span> <span class="n">peer1</span><span class="o">.</span><span class="n">org2</span> <span class="n">on</span> <span class="n">channel</span> <span class="s1">&#39;mychannel&#39;</span> <span class="ow">is</span> <span class="n">successful</span> <span class="o">=====================</span>

<span class="o">=====================</span> <span class="n">All</span> <span class="n">GOOD</span><span class="p">,</span> <span class="n">BYFN</span> <span class="n">execution</span> <span class="n">completed</span> <span class="o">=====================</span>


 <span class="n">_____</span>   <span class="n">_</span>   <span class="n">_</span>   <span class="n">____</span>
<span class="o">|</span> <span class="n">____</span><span class="o">|</span> <span class="o">|</span> \ <span class="o">|</span> <span class="o">|</span> <span class="o">|</span>  <span class="n">_</span> \
<span class="o">|</span>  <span class="n">_</span><span class="o">|</span>   <span class="o">|</span>  \<span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span> <span class="o">|</span>
<span class="o">|</span> <span class="o">|</span><span class="n">___</span>  <span class="o">|</span> <span class="o">|</span>\  <span class="o">|</span> <span class="o">|</span> <span class="o">|</span><span class="n">_</span><span class="o">|</span> <span class="o">|</span>
<span class="o">|</span><span class="n">_____</span><span class="o">|</span> <span class="o">|</span><span class="n">_</span><span class="o">|</span> \<span class="n">_</span><span class="o">|</span> <span class="o">|</span><span class="n">____</span><span class="o">/</span>
</pre></div>
</div>
<p>You can scroll through these logs to see the various transactions.</p>
<p>你可以滚动屏幕，看到各个交易的具体信息。</p>
</div>
<div class="section" id="how-can-i-see-the-chaincode-logs">
<h3>How can I see the chaincode logs? - 如何查看链码的日志？<a class="headerlink" href="#how-can-i-see-the-chaincode-logs" title="Permalink to this headline">¶</a></h3>
<p>Inspect the individual chaincode containers to see the separate
transactions executed against each container. Here is the combined
output from each container:</p>
<p>通过查看各个链码容器，可以看到该容器相关的交易信息。如下是各个容器的日志输出：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker logs dev-peer0.org2.example.com-mycc-1.0
04:30:45.947 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]
ex02 Init
Aval = 100, Bval = 200

$ docker logs dev-peer0.org1.example.com-mycc-1.0
04:31:10.569 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]
ex02 Invoke
Query Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;100&quot;}
ex02 Invoke
Aval = 90, Bval = 210

$ docker logs dev-peer1.org2.example.com-mycc-1.0
04:31:30.420 [BCCSP_FACTORY] DEBU : Initialize BCCSP [SW]
ex02 Invoke
Query Response:{&quot;Name&quot;:&quot;a&quot;,&quot;Amount&quot;:&quot;90&quot;}
</pre></div>
</div>
</div>
</div>
<div class="section" id="understanding-the-docker-compose-topology-docker-compose">
<h2>Understanding the Docker Compose topology - 理解 Docker Compose 的拓扑结构<a class="headerlink" href="#understanding-the-docker-compose-topology-docker-compose" title="Permalink to this headline">¶</a></h2>
<p>The BYFN sample offers us two flavors of Docker Compose files, both of which
are extended from the <code class="docutils literal notranslate"><span class="pre">docker-compose-base.yaml</span></code> (located in the <code class="docutils literal notranslate"><span class="pre">base</span></code>
folder).  Our first flavor, <code class="docutils literal notranslate"><span class="pre">docker-compose-cli.yaml</span></code>, provides us with a
CLI container, along with an orderer, four peers.  We use this file
for the entirety of the instructions on this page.</p>
<p>本示例（BYFN）提供了两种方案的 Docker Compose 配置文件，两个方案都是基于 <code class="docutils literal notranslate"><span class="pre">docker-compose-base.yaml</span></code> （位于 <code class="docutils literal notranslate"><span class="pre">base</span></code> 目录下）扩展而来。第一种方案的配置文件为 <code class="docutils literal notranslate"><span class="pre">docker-compose-cli.yaml</span></code>，提供了 1 个 CLI 容器、1 个排序服务节点以及 4 个对等节点。在本篇介绍中，我们使用的都是此方案。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>the remainder of this section covers a docker-compose file designed for the
SDK.  Refer to the <a class="reference external" href="https://github.com/hyperledger/fabric-sdk-node">Node SDK</a>
repo for details on running these tests.</p>
<p class="last">本节的剩余内容涵盖了一份用于 SDK 的 docker-compose 配置文件。如果想运行这些测试案例，请参考 <a class="reference external" href="https://github.com/hyperledger/fabric-sdk-node">Node SDK</a>。</p>
</div>
<p>The second flavor, <code class="docutils literal notranslate"><span class="pre">docker-compose-e2e.yaml</span></code>, is constructed to run end-to-end tests
using the Node.js SDK.  Aside from functioning with the SDK, its primary differentiation
is that there are containers for the fabric-ca servers.  As a result, we are able
to send REST calls to the organizational CAs for user registration and enrollment.</p>
<p>第二种方案的配置文件为 <code class="docutils literal notranslate"><span class="pre">docker-compose-e2e.yaml</span></code>，该方案构建了一个端到端的测试场景，用于运行 Node.js SDK。除了和 SDK 的交互功能外，该方案最大的区别是包含了作为 fabric-ca 服务器的容器。因此，我们可以通过发送 REST 请求给 CA，实现用户的注册和登记。</p>
<p>If you want to use the <code class="docutils literal notranslate"><span class="pre">docker-compose-e2e.yaml</span></code> without first running the
byfn.sh script, then we will need to make four slight modifications.
We need to point to the private keys for our Organization’s CA’s.  You can locate
these values in your crypto-config folder.  For example, to locate the private
key for Org1 we would follow this path - <code class="docutils literal notranslate"><span class="pre">crypto-config/peerOrganizations/org1.example.com/ca/</span></code>.
The private key is a long hash value followed by <code class="docutils literal notranslate"><span class="pre">_sk</span></code>.  The path for Org2
would be - <code class="docutils literal notranslate"><span class="pre">crypto-config/peerOrganizations/org2.example.com/ca/</span></code>.</p>
<p>如果你希望不通过 byfn.sh 脚本而直接使用 <code class="docutils literal notranslate"><span class="pre">docker-compose-e2e.yaml</span></code> 的话，需要做 4 处修改。我们需要指定机构的 CA 的密钥。你可以指定 crypto-config 文件夹中的值。例如，机构 Org1 的密钥值，可以指定为 <code class="docutils literal notranslate"><span class="pre">crypto-config/peerOrganizations/org1.example.com/ca/</span></code>。密钥包含了一个长哈希值，并以 <code class="docutils literal notranslate"><span class="pre">_sk</span></code> 结尾。机构 Org2 的密钥可以是 <code class="docutils literal notranslate"><span class="pre">crypto-config/peerOrganizations/org2.example.com/ca/</span></code>。</p>
<p>In the  update the FABRIC_CA_SERVER_TLS_KEYFILE variable
for ca0 and ca1.  You also need to edit the path that is provided in the command
to start the ca server.  You are providing the same private key twice for each
CA container.</p>
<p>更新 <code class="docutils literal notranslate"><span class="pre">docker-compose-e2e.yaml</span></code> 中 ca0 和 ca1 的 FABRIC_CA_SERVER_TLS_KEYFILE 值。你还需要修改启动 ca 服务器的命令中的路径。对每一个 CA 容器，你需要提供两次相同的密钥。</p>
</div>
<div class="section" id="using-couchdb-couchdb">
<h2>Using CouchDB - 使用 CouchDB<a class="headerlink" href="#using-couchdb-couchdb" title="Permalink to this headline">¶</a></h2>
<p>The state database can be switched from the default (goleveldb) to CouchDB.
The same chaincode functions are available with CouchDB, however, there is the
added ability to perform rich and complex queries against the state database
data content contingent upon the chaincode data being modeled as JSON.</p>
<p>状态数据库可以从默认的 goleveldb 切换到 CouchDB。CouchDB 提供了相同的链码函数，此外，对于采用 JSON 结构的链码数据，CouchDB 还提供了进行富查询和复杂查询的能力。</p>
<p>To use CouchDB instead of the default database (goleveldb), follow the same
procedures outlined earlier for generating the artifacts, except when starting
the network pass <code class="docutils literal notranslate"><span class="pre">docker-compose-couch.yaml</span></code> as well:</p>
<p>要想使用 CouchDB 替换默认的数据库 (goleveldb)，按照之前完全相同的步骤生成相关配置工件，只是在启动网络时，如下所示增加 <code class="docutils literal notranslate"><span class="pre">docker-compose-couch.yaml</span></code> 文件：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span><span class="o">-</span><span class="n">compose</span> <span class="o">-</span><span class="n">f</span> <span class="n">docker</span><span class="o">-</span><span class="n">compose</span><span class="o">-</span><span class="n">cli</span><span class="o">.</span><span class="n">yaml</span> <span class="o">-</span><span class="n">f</span> <span class="n">docker</span><span class="o">-</span><span class="n">compose</span><span class="o">-</span><span class="n">couch</span><span class="o">.</span><span class="n">yaml</span> <span class="n">up</span> <span class="o">-</span><span class="n">d</span>
</pre></div>
</div>
<p><strong>chaincode_example02</strong> should now work using CouchDB underneath.</p>
<p><strong>chaincode_example02</strong> 此时就是基于 CouchDB 运行。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you choose to implement mapping of the fabric-couchdb container
port to a host port, please make sure you are aware of the security
implications. Mapping of the port in a development environment makes the
CouchDB REST API available, and allows the
visualization of the database via the CouchDB web interface (Fauxton).
Production environments would likely refrain from implementing port mapping in
order to restrict outside access to the CouchDB containers.</p>
<p class="last">如果你将 fabric-couchdb 容器的端口映射到主机端口，请确保你明白其中的安全问题。在开发环境中，端口映射后可以直接访问 CouchDB 的 REST API，还可以通过 CouchDB 网页接口 (Fauxton) 查看可视化后的数据。在生产环境中，应该尽量避免端口映射，严格限制外界对 CouchDB 容器的访问。</p>
</div>
<p>You can use <strong>chaincode_example02</strong> chaincode against the CouchDB state database
using the steps outlined above, however in order to exercise the CouchDB query
capabilities you will need to use a chaincode that has data modeled as JSON,
(e.g. <strong>marbles02</strong>). You can locate the <strong>marbles02</strong> chaincode in the
<code class="docutils literal notranslate"><span class="pre">fabric/examples/chaincode/go</span></code> directory.</p>
<p>基于上述步骤，你可以基于 CouchDB 状态数据库运行 <strong>chaincode_example02</strong> 链码，但是，如果想利用 CouchDB 的查询能力，你还需要一个采用 JSON 结构保存数据的链码 (例如 <strong>marbles02</strong>)。你可以在 <code class="docutils literal notranslate"><span class="pre">fabric/examples/chaincode/go</span></code> 目录下找到 <strong>marbles02</strong> 链码的源文件。</p>
<p>We will follow the same process to create and join the channel as outlined in the
<a class="reference internal" href="#createandjoin"><span class="std std-ref">Create &amp; Join Channel - 创建和加入通道</span></a> section above.  Once you have joined your peer(s) to the
channel, use the following steps to interact with the <strong>marbles02</strong> chaincode:</p>
<p>我们将会采用和 <a class="reference internal" href="#createandjoin"><span class="std std-ref">Create &amp; Join Channel - 创建和加入通道</span></a> 一节相同的步骤去创建和加入通道。在将你的对等节点（们）加入到通道后，采用如下步骤去和 <strong>marbles02</strong> 链码进行交互：</p>
<ul class="simple">
<li>Install and instantiate the chaincode on <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code>:</li>
<li>在 <code class="docutils literal notranslate"><span class="pre">peer0.org1.example.com</span></code> 上安装和实例化链码：</li>
</ul>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to modify the $CHANNEL_NAME variable accordingly for the instantiate command

# 请确保将 $CHANNEL_NAME 修改为实例化命令中对应的值

peer chaincode install -n marbles -v 1.0 -p github.com/chaincode/marbles02/go
peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;OR (&#39;Org0MSP.peer&#39;,&#39;Org1MSP.peer&#39;)&quot;
</pre></div>
</div>
<ul class="simple">
<li>Create some marbles and move them around:</li>
<li>创建一些弹珠 (marble) 并移动它们：</li>
</ul>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span># be sure to modify the $CHANNEL_NAME variable accordingly

# 请确保将 $CHANNEL_NAME 修改为合适的值

peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]}&#39;
peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble2&quot;,&quot;red&quot;,&quot;50&quot;,&quot;tom&quot;]}&#39;
peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble3&quot;,&quot;blue&quot;,&quot;70&quot;,&quot;tom&quot;]}&#39;
peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble2&quot;,&quot;jerry&quot;]}&#39;
peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;transferMarblesBasedOnColor&quot;,&quot;blue&quot;,&quot;jerry&quot;]}&#39;
peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;delete&quot;,&quot;marble1&quot;]}&#39;
</pre></div>
</div>
<ul>
<li><p class="first">If you chose to map the CouchDB ports in docker-compose, you can now view
the state database through the CouchDB web interface (Fauxton) by opening
a browser and navigating to the following URL:</p>
</li>
<li><p class="first">如果你在 docker-compose 中对 CouchDB 进行了端口映射，你可以使用 CouchDB 网页接口 (Fauxton) 去查看状态数据库的内容，需要打开浏览器并输入如下网址：</p>
<p><code class="docutils literal notranslate"><span class="pre">http://localhost:5984/_utils</span></code></p>
</li>
</ul>
<p>You should see a database named <code class="docutils literal notranslate"><span class="pre">mychannel</span></code> (or your unique channel name) and
the documents inside it.</p>
<p>你会看到一个名为 <code class="docutils literal notranslate"><span class="pre">mychannel</span></code> （或你所指定的通道名称）的数据库及其内部的文档。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For the below commands, be sure to update the $CHANNEL_NAME variable appropriately.</p>
<p class="last">对于如下命令，请确保将 $CHANNEL_NAME 修改为合适的值</p>
</div>
<p>You can run regular queries from the CLI (e.g. reading <code class="docutils literal notranslate"><span class="pre">marble2</span></code>):</p>
<p>你可以从 CLI 发起常规查询（例如读取 <code class="docutils literal notranslate"><span class="pre">marble2</span></code>）：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>peer chaincode query -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;readMarble&quot;,&quot;marble2&quot;]}&#39;
</pre></div>
</div>
<p>The output should display the details of <code class="docutils literal notranslate"><span class="pre">marble2</span></code>:</p>
<p>输出为 <code class="docutils literal notranslate"><span class="pre">marble2</span></code> 的详细信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Query</span> <span class="n">Result</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;docType&quot;</span><span class="p">:</span><span class="s2">&quot;marble&quot;</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;marble2&quot;</span><span class="p">,</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span><span class="s2">&quot;jerry&quot;</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">50</span><span class="p">}</span>
</pre></div>
</div>
<p>You can retrieve the history of a specific marble - e.g. <code class="docutils literal notranslate"><span class="pre">marble1</span></code>:</p>
<p>你可以获取指定弹珠的历史信息 - 例如 <code class="docutils literal notranslate"><span class="pre">marble1</span></code>：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>peer chaincode query -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;getHistoryForMarble&quot;,&quot;marble1&quot;]}&#39;
</pre></div>
</div>
<p>The output should display the transactions on <code class="docutils literal notranslate"><span class="pre">marble1</span></code>:</p>
<p>输出为 <code class="docutils literal notranslate"><span class="pre">marble1</span></code> 相关的所有交易：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Query</span> <span class="n">Result</span><span class="p">:</span> <span class="p">[{</span><span class="s2">&quot;TxId&quot;</span><span class="p">:</span><span class="s2">&quot;1c3d3caf124c89f91a4c0f353723ac736c58155325f02890adebaa15e16e6464&quot;</span><span class="p">,</span> <span class="s2">&quot;Value&quot;</span><span class="p">:{</span><span class="s2">&quot;docType&quot;</span><span class="p">:</span><span class="s2">&quot;marble&quot;</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;marble1&quot;</span><span class="p">,</span><span class="s2">&quot;color&quot;</span><span class="p">:</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">35</span><span class="p">,</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span><span class="s2">&quot;tom&quot;</span><span class="p">}},{</span><span class="s2">&quot;TxId&quot;</span><span class="p">:</span><span class="s2">&quot;755d55c281889eaeebf405586f9e25d71d36eb3d35420af833a20a2f53a3eefd&quot;</span><span class="p">,</span> <span class="s2">&quot;Value&quot;</span><span class="p">:{</span><span class="s2">&quot;docType&quot;</span><span class="p">:</span><span class="s2">&quot;marble&quot;</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;marble1&quot;</span><span class="p">,</span><span class="s2">&quot;color&quot;</span><span class="p">:</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">35</span><span class="p">,</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span><span class="s2">&quot;jerry&quot;</span><span class="p">}},{</span><span class="s2">&quot;TxId&quot;</span><span class="p">:</span><span class="s2">&quot;819451032d813dde6247f85e56a89262555e04f14788ee33e28b232eef36d98f&quot;</span><span class="p">,</span> <span class="s2">&quot;Value&quot;</span><span class="p">:}]</span>
</pre></div>
</div>
<p>You can also perform rich queries on the data content, such as querying marble fields by owner <code class="docutils literal notranslate"><span class="pre">jerry</span></code>:</p>
<p>你还可以基于数据内容发起一个富查询，例如查询所有者 (owner) 为 <code class="docutils literal notranslate"><span class="pre">jerry</span></code> 的弹珠：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>peer chaincode query -C $CHANNEL_NAME -n marbles -c &#39;{&quot;Args&quot;:[&quot;queryMarblesByOwner&quot;,&quot;jerry&quot;]}&#39;
</pre></div>
</div>
<p>The output should display the two marbles owned by <code class="docutils literal notranslate"><span class="pre">jerry</span></code>:</p>
<p>输出为 <code class="docutils literal notranslate"><span class="pre">jerry</span></code> 拥有的两个弹珠信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Query</span> <span class="n">Result</span><span class="p">:</span> <span class="p">[{</span><span class="s2">&quot;Key&quot;</span><span class="p">:</span><span class="s2">&quot;marble2&quot;</span><span class="p">,</span> <span class="s2">&quot;Record&quot;</span><span class="p">:{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span><span class="s2">&quot;red&quot;</span><span class="p">,</span><span class="s2">&quot;docType&quot;</span><span class="p">:</span><span class="s2">&quot;marble&quot;</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;marble2&quot;</span><span class="p">,</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span><span class="s2">&quot;jerry&quot;</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">50</span><span class="p">}},{</span><span class="s2">&quot;Key&quot;</span><span class="p">:</span><span class="s2">&quot;marble3&quot;</span><span class="p">,</span> <span class="s2">&quot;Record&quot;</span><span class="p">:{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="s2">&quot;docType&quot;</span><span class="p">:</span><span class="s2">&quot;marble&quot;</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">:</span><span class="s2">&quot;marble3&quot;</span><span class="p">,</span><span class="s2">&quot;owner&quot;</span><span class="p">:</span><span class="s2">&quot;jerry&quot;</span><span class="p">,</span><span class="s2">&quot;size&quot;</span><span class="p">:</span><span class="mi">70</span><span class="p">}}]</span>
</pre></div>
</div>
</div>
<div class="section" id="why-couchdb-couchdb">
<h2>Why CouchDB - 为何使用 CouchDB<a class="headerlink" href="#why-couchdb-couchdb" title="Permalink to this headline">¶</a></h2>
<p>CouchDB is a kind of NoSQL solution. It is a document oriented database where document fields are stored as key-value mpas. Fields can be either a simple key/value pair, list, or map.
In addition to keyed/composite-key/key-range queries which are supported by LevelDB, CouchDB also supports full data rich queries capability, such as non-key queries against the whole blockchain data,
since its data content is stored in JSON format and fully queryable. Therefore, CouchDB can meet chaincode, auditing, reporting requirements for many use cases that not supported by LevelDB.</p>
<p>CouchDB 是 NoSQL 的一种解决方案。它是一种面向文档的数据库，其中文档字段以键-值 (key-value) 的形式保存。字段可以是简单的键值对 (key/value pair)、列表 (list) 或者图 (map)。CouchDB 不仅支持 LevelDB 所支持的 keyed/composite-key/key-range 等查询方式，还提供了全数据富查询的能力，例如对于整个区块链数据的无键查询 (non-key queries)，这是因为 CouchDB 的数据内容使用了 JSON 格式进行存储，提供了全方位的查询能力。因此，在一些  LevelDB 无法支持的应用场景下，CouchDB 还可以满足链码、审计和报告等需求。</p>
<p>CouchDB can also enhance the security for compliance and data protection in the blockchain. As it is able to implement field-level security through the filtering and masking of individual attributes within a transaction, and only authorizing the read-only permission if needed.</p>
<p>CouchDB 还可以增强区块链中合规和数据保护的安全性。通过过滤和提取交易中的独立属性，它具备了字段级别的安全性，在需要时授予只读权限即可。</p>
<p>In addition, CouchDB falls into the AP-type (Availability and Partition Tolerance) of the CAP theorem. It uses a master-master replication model with <code class="docutils literal notranslate"><span class="pre">Eventual</span> <span class="pre">Consistency</span></code>.
More information can be found on the
<a class="reference external" href="http://docs.couchdb.org/en/latest/intro/consistency.html">Eventual Consistency page of the CouchDB documentation</a>.
However, under each fabric peer, there is no database replicas, writes to database are guaranteed consistent and durable (not <code class="docutils literal notranslate"><span class="pre">Eventual</span> <span class="pre">Consistency</span></code>).</p>
<p>此外，CouchDB 是 CAP 理论中的 AP 类型 (可用性和分区容错性，Availability and Partition Tolerance)。它利用主 - 主复制模型 (master-master replication model) 实现了 <code class="docutils literal notranslate"><span class="pre">最终一致性</span> <span class="pre">(Eventual</span> <span class="pre">Consistency)</span></code>。更详细的信息请参考 <a class="reference external" href="http://docs.couchdb.org/en/latest/intro/consistency.html">Eventual Consistency page of the CouchDB documentation</a> 。然而，在每个 fabric 的对等节点内，并不包含数据库拷贝，对数据库的写入是担保形式的一致性和持久性 (非 <code class="docutils literal notranslate"><span class="pre">最终一致性</span></code> )。</p>
<p>CouchDB is the first external pluggable state database for Fabric, and there could and should be other external database options. For example, IBM enables the relational database for its blockchain.
And the CP-type (Consistency and Partition Tolerance) databases may also in need, so as to enable data consistency without application level guarantee.</p>
<p>CouchDB 是 Fabric 的第一个可插拔的外部状态数据库，可以有也应该有其他的外部数据库选项。例如，IBM 在它的区块链中采用了关系型数据库。此外，CP 类型 (一致性和分区容错性，Consistency and Partition Tolerance) 的数据库也是需要的，这样可以在不需要应用层担保的情况下实现数据的一致性。</p>
</div>
<div class="section" id="a-note-on-data-persistence">
<h2>A Note on Data Persistence - 数据持久化的注意事项<a class="headerlink" href="#a-note-on-data-persistence" title="Permalink to this headline">¶</a></h2>
<p>If data persistence is desired on the peer container or the CouchDB container,
one option is to mount a directory in the docker-host into a relevant directory
in the container. For example, you may add the following two lines in
the peer container specification in the <code class="docutils literal notranslate"><span class="pre">docker-compose-base.yaml</span></code> file:</p>
<p>如果对等节点的容器或者 CouchDB 容器需要进行数据持久化，一种方法是将主机的目录挂载到容器内的相关目录。例如你可以将如下两行添加到 <code class="docutils literal notranslate"><span class="pre">docker-compose-base.yaml</span></code> 文件中对等节点容器的配置中：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volumes</span><span class="p">:</span>
 <span class="o">-</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">peer0</span><span class="p">:</span><span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">production</span>
</pre></div>
</div>
<p>For the CouchDB container, you may add the following two lines in the CouchDB
container specification:</p>
<p>对于 CouchDB 容器，你可以添加如下两行到 CouchDB 容器的配置中：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">volumes</span><span class="p">:</span>
 <span class="o">-</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">couchdb0</span><span class="p">:</span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">couchdb</span><span class="o">/</span><span class="n">data</span>
</pre></div>
</div>
</div>
<div class="section" id="troubleshooting">
<span id="troubleshoot"></span><h2>Troubleshooting - 疑难解答<a class="headerlink" href="#troubleshooting" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Always start your network fresh.  Use the following command
to remove artifacts, crypto, containers and chaincode images:</p>
</li>
<li><p class="first">总是在全新的环境下启动你的网络。 使用如下命令来删除工件、加密文件、容器以及链码镜像：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">byfn</span><span class="o">.</span><span class="n">sh</span> <span class="o">-</span><span class="n">m</span> <span class="n">down</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>You <strong>will</strong> see errors if you do not remove old containers
and images.</p>
<p class="last">如果你没有删除旧的容器和镜像，你 <strong>将会</strong> 看到错误</p>
</div>
</li>
<li><p class="first">If you see Docker errors, first check your docker version (<a class="reference internal" href="prereqs.html"><span class="doc">预备知识</span></a>),
and then try restarting your Docker process.  Problems with Docker are
oftentimes not immediately recognizable.  For example, you may see errors
resulting from an inability to access crypto material mounted within a
container.</p>
</li>
<li><p class="first">如果你看到 Docker 错误，首先检查你的 docker 版本 (<a class="reference internal" href="prereqs.html"><span class="doc">预备知识</span></a>)，随后尝试重启你的 Docker 进程。Docker 相关的问题有时并不能很直观的被发现。例如，如果容器内没有权限读取挂载的加密文件，你会看到错误。</p>
<p>If they persist remove your images and start from scratch:</p>
<p>如果这些错误始终存在，删除你的镜像，随后从头开始：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>docker rm -f $(docker ps -aq)
docker rmi -f $(docker images -q)
</pre></div>
</div>
</li>
<li><p class="first">If you see errors on your create, instantiate, invoke or query commands, make
sure you have properly updated the channel name and chaincode name.  There
are placeholder values in the supplied sample commands.</p>
</li>
<li><p class="first">如果在执行创建、实例化、调用或查询链码命令时遇到错误，请确保你已经正确更新了通道名称和链码名称。在提供的示例命令中包含一些占位的变量。</p>
</li>
<li><p class="first">If you see the below error:</p>
</li>
<li><p class="first">如果你看到如下错误</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span><span class="p">:</span> <span class="n">Error</span> <span class="n">endorsing</span> <span class="n">chaincode</span><span class="p">:</span> <span class="n">rpc</span> <span class="n">error</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">Error</span> <span class="n">installing</span> <span class="n">chaincode</span> <span class="n">code</span> <span class="n">mycc</span><span class="p">:</span><span class="mf">1.0</span><span class="p">(</span><span class="n">chaincode</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">hyperledger</span><span class="o">/</span><span class="n">production</span><span class="o">/</span><span class="n">chaincodes</span><span class="o">/</span><span class="n">mycc</span><span class="o">.</span><span class="mf">1.0</span> <span class="n">exits</span><span class="p">)</span>
</pre></div>
</div>
<p>You likely have chaincode images (e.g. <code class="docutils literal notranslate"><span class="pre">dev-peer1.org2.example.com-mycc-1.0</span></code> or
<code class="docutils literal notranslate"><span class="pre">dev-peer0.org1.example.com-mycc-1.0</span></code>) from prior runs. Remove them and try
again.</p>
<p>很有可能是还有之前运行网络时生成的链码镜像（例如 <code class="docutils literal notranslate"><span class="pre">dev-peer1.org2.example.com-mycc-1.0</span></code> 或
<code class="docutils literal notranslate"><span class="pre">dev-peer0.org1.example.com-mycc-1.0</span></code> ）。把它们删除后重试。</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>docker rmi -f $(docker images | grep peer[0-9]-peer[0-9] | awk &#39;{print $3}&#39;)
</pre></div>
</div>
</li>
<li><p class="first">If you see something similar to the following:</p>
</li>
<li><p class="first">如果你看到类似如下的内容：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Error</span> <span class="n">connecting</span><span class="p">:</span> <span class="n">rpc</span> <span class="n">error</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">14</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">grpc</span><span class="p">:</span> <span class="n">RPC</span> <span class="n">failed</span> <span class="n">fast</span> <span class="n">due</span> <span class="n">to</span> <span class="n">transport</span> <span class="n">failure</span>
<span class="n">Error</span><span class="p">:</span> <span class="n">rpc</span> <span class="n">error</span><span class="p">:</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">14</span> <span class="n">desc</span> <span class="o">=</span> <span class="n">grpc</span><span class="p">:</span> <span class="n">RPC</span> <span class="n">failed</span> <span class="n">fast</span> <span class="n">due</span> <span class="n">to</span> <span class="n">transport</span> <span class="n">failure</span>
</pre></div>
</div>
<p>Make sure you are running your network against the “1.0.0” images that have
been retagged as “latest”.</p>
<p>请确保你是基于 “1.1.0” 版本的镜像运行你的网络，并且这些镜像都被标记为 “latest”。</p>
</li>
<li><p class="first">If you see the below error:</p>
</li>
<li><p class="first">如果你看到如下错误：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">configtx</span><span class="o">/</span><span class="n">tool</span><span class="o">/</span><span class="n">localconfig</span><span class="p">]</span> <span class="n">Load</span> <span class="o">-&gt;</span> <span class="n">CRIT</span> <span class="mi">002</span> <span class="n">Error</span> <span class="n">reading</span> <span class="n">configuration</span><span class="p">:</span> <span class="n">Unsupported</span> <span class="n">Config</span> <span class="n">Type</span> <span class="s2">&quot;&quot;</span>
<span class="n">panic</span><span class="p">:</span> <span class="n">Error</span> <span class="n">reading</span> <span class="n">configuration</span><span class="p">:</span> <span class="n">Unsupported</span> <span class="n">Config</span> <span class="n">Type</span> <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
<p>Then you did not set the <code class="docutils literal notranslate"><span class="pre">FABRIC_CFG_PATH</span></code> environment variable properly.  The
configtxgen tool needs this variable in order to locate the configtx.yaml.  Go
back and execute an <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">FABRIC_CFG_PATH=$PWD</span></code>, then recreate your
channel artifacts.</p>
<p>这是由于你没有设置环境变量 <code class="docutils literal notranslate"><span class="pre">FABRIC_CFG_PATH</span></code> 导致的。configtxgen 工具需要依赖这个变量来访问 configtx.yaml。执行 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">FABRIC_CFG_PATH=$PWD</span></code> ，然后重新创建你的通道配置工件。</p>
</li>
<li><p class="first">To cleanup the network, use the <code class="docutils literal notranslate"><span class="pre">down</span></code> option:</p>
</li>
<li><p class="first">使用 <code class="docutils literal notranslate"><span class="pre">down</span></code> 选项清理网络：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">byfn</span><span class="o">.</span><span class="n">sh</span> <span class="o">-</span><span class="n">m</span> <span class="n">down</span>
</pre></div>
</div>
</li>
<li><p class="first">If you see an error stating that you still have “active endpoints”, then prune
your Docker networks.  This will wipe your previous networks and start you with a
fresh environment:</p>
</li>
<li><p class="first">如果你看到错误提示是还有 “active endpoints”，请删除你的 Docker 网络。如下命令会清空之前的网络，使你可以从一个全新环境开始：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">network</span> <span class="n">prune</span>
</pre></div>
</div>
<p>You will see the following message:</p>
<p>你会看到如下信息：</p>
<div class="code bash highlight-default notranslate"><div class="highlight"><pre><span></span>WARNING! This will remove all networks not used by at least one container.
Are you sure you want to continue? [y/N]
</pre></div>
</div>
<p>Select <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>选择 <code class="docutils literal notranslate"><span class="pre">y</span></code>。</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you continue to see errors, share your logs on the
<strong>fabric-questions</strong> channel on
<a class="reference external" href="https://chat.hyperledger.org/home">Hyperledger Rocket Chat</a>
or on <a class="reference external" href="https://stackoverflow.com/questions/tagged/hyperledger-fabric">StackOverflow</a>.</p>
<p class="last">如果你还是遇到错误，请将你的日志分享到 <a class="reference external" href="https://chat.hyperledger.org/home">Hyperledger Rocket Chat</a> 的 <strong>fabric-questions</strong> 频道下，或者 <a class="reference external" href="https://stackoverflow.com/questions/tagged/hyperledger-fabric">StackOverflow</a> 。</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="write_first_app.html" class="btn btn-neutral float-right" title="Writing Your First Application - 编写你的第一个应用" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tutorials.html" class="btn btn-neutral" title="Tutorials - 教程" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Hyperledger 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'master',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>